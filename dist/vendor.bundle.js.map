{"version":3,"sources":["webpack:///vendor.bundle.js","webpack:///webpack/bootstrap ec1bd3faff834bcb88c9","webpack:///./src/vendor.js","webpack:///./~/riot/riot.js","webpack:///./src/css/tacit.min.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/es6-promise/dist/es6-promise.js","webpack:///./~/isomorphic-fetch/fetch-npm-browserify.js","webpack:///./~/process/browser.js","webpack:///./~/stackable/dist/stackable-browsify.js","webpack:///./~/stackable/dist/stackable.js","webpack:///./~/style-loader/addStyles.js","webpack:///./src/css/tacit.min.css?4899","webpack:///(webpack)/buildin/amd-define.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/whatwg-fetch/fetch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift",0,"e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","__WEBPACK_AMD_DEFINE_RESULT__","mkitem","expr","key","val","item","pos","unmountRedundant","items","tags","t","j","splice","unmount","moveNestedTags","child","Object","keys","forEach","tagName","tag","isArray","each","moveChildTag","addVirtual","target","sib","el","_root","_virts","nextSibling","insertBefore","moveVirtual","len","_each","dom","parent","remAttr","hasKeys","mustReorder","getAttr","T_STRING","getTagName","impl","__tagImpl","tmpl","outerHTML","useRoot","SPECIAL_TAGS_REGEX","test","root","parentNode","ref","createTextNode","getTag","isOption","toLowerCase","oldItems","isVirtual","loopKeys","one","removeChild","stub","on","frag","createDocumentFragment","map","itemsLength","_mustReorder","oldPos","indexOf","Tag","isLoop","hasImpl","cloneNode","innerHTML","mount","firstChild","update","childNodes","_item","defineProperty","FIREFOX","multiple","n","__riot1374","selectedIndex","slice","parseNamedElements","childTags","forceParsingNamed","walk","nodeType","initChildTag","setNamed","parseExpressions","expressions","addExpr","extra","hasExpr","extend","attr","nodeValue","attributes","name","bool","split","value","conf","updateOpts","ctx","self","opts","toCamel","normalizeData","data","T_UNDEF","isWritable","inheritFromParent","k","mustSync","contains","RESERVED_WORDS_BLACKLIST","propsInSyncWithParent","onChildUpdate","toggle","isMount","evt","riot","observable","this","inherit","cleanUpData","_tag","isMounted","__uid","mkdom","isInherited","isObject","trigger","rAF","arguments","mix","instance","mixin","isFunction","prototype","getOwnPropertyNames","bind","init","globalMixin","GLOBAL_MIXIN","fn","attrs","walkAttributes","v","setAttr","isInStub","keepRootTag","ptag","tagIndex","__virtualDom","getImmediateCustomParentTag","_riot_id","RIOT_TAG_IS","RIOT_TAG","off","setEventHandler","handler","_parent","event","currentTarget","srcElement","which","charCode","keyCode","preventDefault","returnValue","preventUpdate","insertTo","node","before","attrName","IE_VERSION","add","remove","inStub","style","display","T_OBJECT","startsWith","RIOT_PREFIX","els","T_FUNCTION","removeAttribute","string","replace","_","toUpperCase","getAttribute","setAttribute","addChildTag","cachedTag","newPos","options","enumerable","writable","configurable","namedTag","obj","args","arr","a","Array","props","getOwnPropertyDescriptor","o","html","re","exec","mkEl","$$","selector","querySelectorAll","$","querySelector","Child","getNamedKey","isArr","str","mountTo","_innerHTML","version","settings","documentMode","InstallTrigger","onEachEvent","defineProperties","events","typed","cb","fns","arglen","busy","concat","DEFAULT_PARSER","path","DEFAULT_SECOND_PARSER","filter","RegExp","REPLACE","match","debounce","delay","clearTimeout","setTimeout","start","autoExec","debouncedEmit","emit","win","ADD_EVENT_LISTENER","POPSTATE","HASHCHANGE","doc","clickEvent","click","Router","central","s","normalize","isString","getPathFromRoot","href","loc","RE_ORIGIN","getPathFromBase","base","force","isRoot","emitStackLevel","MAX_EMIT_STACK_LEVEL","emitStack","current","TRIGGER","metaKey","ctrlKey","shiftKey","defaultPrevented","nodeName","HAS_ATTRIBUTE","go","title","shouldReplace","hist","replaceState","pushState","routeFound","parser","secondParser","EVENT_LISTENER","REMOVE_EVENT_LISTENER","history","location","prot","ontouchstart","started","first","second","third","r","some","action","mainRouter","route","create","newSubRouter","router","stop","arg","fn2","query","q","readyState","brackets","UNDEF","_loopback","_rewrite","bp","_cache","source","global","REGLOB","_create","pair","DEFAULT","_pairs","Error","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","set","get","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","index","trim","array","_tmpl","_logErr","err","errorHandler","riotData","_getTmpl","Function","qstr","RE_DQUOTE","list","_parseExpr","join","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","haveRaw","hasRaw","parse","_mkdom","templ","replaceYield","tblTags","specialTags","select","tname","rootEls","childElementCount","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","tr","th","td","col","styleManager","_riot","inject","styleNode","newNode","userNode","replaceChild","cssTextProp","styleSheet","stylesToInject","css","cssText","w","raf","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","navigator","userAgent","lastTime","nowtime","Date","now","timeout","Math","max","util","mixins","tag2","addRiotTags","selectAllTags","pushTags","riotTag","allTags","nodeList","_el","vdom","toString","result","mediaQuery","alreadyImportedModules","process","lib$es6$promise$utils$$objectOrFunction","x","lib$es6$promise$utils$$isFunction","lib$es6$promise$asap$$setScheduler","scheduleFn","lib$es6$promise$asap$$customSchedulerFn","lib$es6$promise$asap$$setAsap","asapFn","lib$es6$promise$asap$$asap","lib$es6$promise$asap$$useNextTick","nextTick","lib$es6$promise$asap$$flush","lib$es6$promise$asap$$useVertxTimer","lib$es6$promise$asap$$vertxNext","lib$es6$promise$asap$$useMutationObserver","iterations","observer","lib$es6$promise$asap$$BrowserMutationObserver","observe","characterData","lib$es6$promise$asap$$useMessageChannel","channel","MessageChannel","port1","onmessage","port2","postMessage","lib$es6$promise$asap$$useSetTimeout","lib$es6$promise$asap$$len","lib$es6$promise$asap$$queue","lib$es6$promise$asap$$attemptVertx","vertx","runOnLoop","runOnContext","lib$es6$promise$then$$then","onFulfillment","onRejection","state","_state","lib$es6$promise$$internal$$FULFILLED","lib$es6$promise$$internal$$REJECTED","constructor","lib$es6$promise$$internal$$noop","_result","lib$es6$promise$$internal$$invokeCallback","lib$es6$promise$$internal$$subscribe","lib$es6$promise$promise$resolve$$resolve","object","Constructor","promise","lib$es6$promise$$internal$$resolve","lib$es6$promise$$internal$$selfFulfillment","TypeError","lib$es6$promise$$internal$$cannotReturnOwn","lib$es6$promise$$internal$$getThen","then","error","lib$es6$promise$$internal$$GET_THEN_ERROR","lib$es6$promise$$internal$$tryThen","fulfillmentHandler","rejectionHandler","lib$es6$promise$$internal$$handleForeignThenable","thenable","sealed","lib$es6$promise$$internal$$fulfill","reason","lib$es6$promise$$internal$$reject","_label","lib$es6$promise$$internal$$handleOwnThenable","lib$es6$promise$$internal$$handleMaybeThenable","maybeThenable","lib$es6$promise$then$$default","resolve","lib$es6$promise$promise$resolve$$default","lib$es6$promise$$internal$$publishRejection","_onerror","lib$es6$promise$$internal$$publish","lib$es6$promise$$internal$$PENDING","_subscribers","subscribers","settled","detail","lib$es6$promise$$internal$$ErrorObject","lib$es6$promise$$internal$$tryCatch","lib$es6$promise$$internal$$TRY_CATCH_ERROR","succeeded","failed","hasCallback","lib$es6$promise$$internal$$initializePromise","resolver","lib$es6$promise$promise$all$$all","entries","lib$es6$promise$enumerator$$default","lib$es6$promise$promise$race$$race","lib$es6$promise$utils$$isArray","lib$es6$promise$promise$reject$$reject","lib$es6$promise$promise$$needsResolver","lib$es6$promise$promise$$needsNew","lib$es6$promise$promise$$Promise","_id","lib$es6$promise$promise$$counter","lib$es6$promise$enumerator$$Enumerator","input","_instanceConstructor","_input","_remaining","_enumerate","_validationError","lib$es6$promise$polyfill$$polyfill","local","P","Promise","cast","lib$es6$promise$promise$$default","lib$es6$promise$utils$$_isArray","lib$es6$promise$asap$$scheduleFlush","lib$es6$promise$asap$$browserWindow","lib$es6$promise$asap$$browserGlobal","MutationObserver","WebKitMutationObserver","lib$es6$promise$asap$$isNode","lib$es6$promise$asap$$isWorker","Uint8ClampedArray","importScripts","lib$es6$promise$promise$all$$default","lib$es6$promise$promise$race$$default","lib$es6$promise$promise$reject$$default","all","race","reject","_setScheduler","_setAsap","_asap","catch","_eachEntry","entry","_settledAt","_willSettleAt","enumerator","lib$es6$promise$polyfill$$default","lib$es6$promise$umd$$ES6Promise","polyfill","fetch","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","run","Item","fun","noop","browser","env","argv","versions","addListener","once","removeListener","removeAllListeners","binding","cwd","chdir","dir","umask","_interopRequireDefault","__esModule","default","_stackable","_stackable2","Stackable","_classCallCheck","_createClass","descriptor","protoProps","staticProps","token","_token","_apiVersion","_apiUrl","_get","res","containerId","itemId","_post","_put","endPoint","response","status","message","json","params","paramsStr","encodeURIComponent","method","headers","Content-type","body","addStylesToDom","styles","domStyle","stylesInDom","refs","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","idx","createStyleElement","createLinkElement","linkElement","rel","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","applyToTag","newObj","replaceText","cssNode","unescape","JSON","stringify","blob","oldSrc","memoize","memo","isOldIE","newList","mayRemove","textStore","replacement","Boolean","content","locals","__webpack_amd_options__","webpackPolyfill","deprecate","paths","children","normalizeName","String","normalizeValue","Headers","append","consumed","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","support","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","arrayBuffer","ArrayBuffer","rejected","decode","normalizeMethod","upcased","methods","Request","url","credentials","mode","referrer","form","bytes","decodeURIComponent","xhr","pairs","getAllResponseHeaders","header","Response","bodyInit","ok","statusText","values","getAll","has","hasOwnProperty","thisArg","clone","redirectStatuses","redirect","RangeError","responseURL","getResponseHeader","request","XMLHttpRequest","responseText","open","withCredentials","responseType","setRequestHeader","send"],"mappings":"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","file":"vendor.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!***********************!*\\\n  !*** ./src/vendor.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(/*! ./css/tacit.min.css */ 20);\n\t\n\t__webpack_require__(/*! riot */ 1);\n\t\n\t__webpack_require__(/*! stackable */ 17);\n\n/***/ },\n/* 1 */\n/*!************************!*\\\n  !*** ./~/riot/riot.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* Riot v2.3.18, @license MIT */\n\t\n\t;(function(window, undefined) {\n\t  'use strict';\n\tvar riot = { version: 'v2.3.18', settings: {} },\n\t  // be aware, internal usage\n\t  // ATTENTION: prefix the global dynamic variables with `__`\n\t\n\t  // counter to give a unique id to all the Tag instances\n\t  __uid = 0,\n\t  // tags instances cache\n\t  __virtualDom = [],\n\t  // tags implementation cache\n\t  __tagImpl = {},\n\t\n\t  /**\n\t   * Const\n\t   */\n\t  GLOBAL_MIXIN = '__global_mixin',\n\t\n\t  // riot specific prefixes\n\t  RIOT_PREFIX = 'riot-',\n\t  RIOT_TAG = RIOT_PREFIX + 'tag',\n\t  RIOT_TAG_IS = 'data-is',\n\t\n\t  // for typeof == '' comparisons\n\t  T_STRING = 'string',\n\t  T_OBJECT = 'object',\n\t  T_UNDEF  = 'undefined',\n\t  T_FUNCTION = 'function',\n\t  // special native tags that cannot be treated like the others\n\t  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n\t  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\t\n\t  // version# for IE 8-11, 0 for others\n\t  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\t\n\t  // detect firefox to fix #1374\n\t  FIREFOX = window && !!window.InstallTrigger\n\t/* istanbul ignore next */\n\triot.observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {}\n\t\n\t  /**\n\t   * Private variables and methods\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice,\n\t    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) }\n\t\n\t  // extend the object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n\t     * @param  { String } events - events ids\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(events, fn) {\n\t        if (typeof fn != 'function')  return el\n\t\n\t        onEachEvent(events, function(name, pos) {\n\t          (callbacks[name] = callbacks[name] || []).push(fn)\n\t          fn.typed = pos > 0\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given space separated list of `events` listeners\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(events, fn) {\n\t        if (events == '*' && !fn) callbacks = {}\n\t        else {\n\t          onEachEvent(events, function(name) {\n\t            if (fn) {\n\t              var arr = callbacks[name]\n\t              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t                if (cb == fn) arr.splice(i--, 1)\n\t              }\n\t            } else delete callbacks[name]\n\t          })\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given space separated list of `events` and execute the `callback` at most once\n\t     * @param   { String } events - events ids\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(events, fn) {\n\t        function on() {\n\t          el.off(events, on)\n\t          fn.apply(el, arguments)\n\t        }\n\t        return el.on(events, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to the given space separated list of `events`\n\t     * @param   { String } events - events ids\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(events) {\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns\n\t\n\t        for (var i = 0; i < arglen; i++) {\n\t          args[i] = arguments[i + 1] // skip first argument\n\t        }\n\t\n\t        onEachEvent(events, function(name) {\n\t\n\t          fns = slice.call(callbacks[name] || [], 0)\n\t\n\t          for (var i = 0, fn; fn = fns[i]; ++i) {\n\t            if (fn.busy) return\n\t            fn.busy = 1\n\t            fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t            if (fns[i] !== fn) { i-- }\n\t            fn.busy = 0\n\t          }\n\t\n\t          if (callbacks['*'] && name != '*')\n\t            el.trigger.apply(el, ['*', name].concat(args))\n\t\n\t        })\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  })\n\t\n\t  return el\n\t\n\t}\n\t/* istanbul ignore next */\n\t;(function(riot) {\n\t\n\t/**\n\t * Simple client-side router\n\t * @module riot-route\n\t */\n\t\n\t\n\tvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/,\n\t  EVENT_LISTENER = 'EventListener',\n\t  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n\t  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n\t  HAS_ATTRIBUTE = 'hasAttribute',\n\t  REPLACE = 'replace',\n\t  POPSTATE = 'popstate',\n\t  HASHCHANGE = 'hashchange',\n\t  TRIGGER = 'trigger',\n\t  MAX_EMIT_STACK_LEVEL = 3,\n\t  win = typeof window != 'undefined' && window,\n\t  doc = typeof document != 'undefined' && document,\n\t  hist = win && history,\n\t  loc = win && (hist.location || win.location), // see html5-history-api\n\t  prot = Router.prototype, // to minify more\n\t  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n\t  started = false,\n\t  central = riot.observable(),\n\t  routeFound = false,\n\t  debouncedEmit,\n\t  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\t\n\t/**\n\t * Default parser. You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_PARSER(path) {\n\t  return path.split(/[/?#]/)\n\t}\n\t\n\t/**\n\t * Default parser (second). You can replace it via router.parser method.\n\t * @param {string} path - current path (normalized)\n\t * @param {string} filter - filter string (normalized)\n\t * @returns {array} array\n\t */\n\tfunction DEFAULT_SECOND_PARSER(path, filter) {\n\t  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n\t    args = path.match(re)\n\t\n\t  if (args) return args.slice(1)\n\t}\n\t\n\t/**\n\t * Simple/cheap debounce implementation\n\t * @param   {function} fn - callback\n\t * @param   {number} delay - delay in seconds\n\t * @returns {function} debounced function\n\t */\n\tfunction debounce(fn, delay) {\n\t  var t\n\t  return function () {\n\t    clearTimeout(t)\n\t    t = setTimeout(fn, delay)\n\t  }\n\t}\n\t\n\t/**\n\t * Set the window listeners to trigger the routes\n\t * @param {boolean} autoExec - see route.start\n\t */\n\tfunction start(autoExec) {\n\t  debouncedEmit = debounce(emit, 1)\n\t  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t  doc[ADD_EVENT_LISTENER](clickEvent, click)\n\t  if (autoExec) emit(true)\n\t}\n\t\n\t/**\n\t * Router class\n\t */\n\tfunction Router() {\n\t  this.$ = []\n\t  riot.observable(this) // make it observable\n\t  central.on('stop', this.s.bind(this))\n\t  central.on('emit', this.e.bind(this))\n\t}\n\t\n\tfunction normalize(path) {\n\t  return path[REPLACE](/^\\/|\\/$/, '')\n\t}\n\t\n\tfunction isString(str) {\n\t  return typeof str == 'string'\n\t}\n\t\n\t/**\n\t * Get the part after domain name\n\t * @param {string} href - fullpath\n\t * @returns {string} path from root\n\t */\n\tfunction getPathFromRoot(href) {\n\t  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n\t}\n\t\n\t/**\n\t * Get the part after base\n\t * @param {string} href - fullpath\n\t * @returns {string} path from base\n\t */\n\tfunction getPathFromBase(href) {\n\t  return base[0] == '#'\n\t    ? (href || loc.href || '').split(base)[1] || ''\n\t    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')\n\t}\n\t\n\tfunction emit(force) {\n\t  // the stack is needed for redirections\n\t  var isRoot = emitStackLevel == 0\n\t  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\t\n\t  emitStackLevel++\n\t  emitStack.push(function() {\n\t    var path = getPathFromBase()\n\t    if (force || path != current) {\n\t      central[TRIGGER]('emit', path)\n\t      current = path\n\t    }\n\t  })\n\t  if (isRoot) {\n\t    while (emitStack.length) {\n\t      emitStack[0]()\n\t      emitStack.shift()\n\t    }\n\t    emitStackLevel = 0\n\t  }\n\t}\n\t\n\tfunction click(e) {\n\t  if (\n\t    e.which != 1 // not left click\n\t    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n\t    || e.defaultPrevented // or default prevented\n\t  ) return\n\t\n\t  var el = e.target\n\t  while (el && el.nodeName != 'A') el = el.parentNode\n\t\n\t  if (\n\t    !el || el.nodeName != 'A' // not A tag\n\t    || el[HAS_ATTRIBUTE]('download') // has download attr\n\t    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n\t    || el.target && el.target != '_self' // another window or frame\n\t    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n\t  ) return\n\t\n\t  if (el.href != loc.href) {\n\t    if (\n\t      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n\t      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n\t      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n\t    ) return\n\t  }\n\t\n\t  e.preventDefault()\n\t}\n\t\n\t/**\n\t * Go to the path\n\t * @param {string} path - destination path\n\t * @param {string} title - page title\n\t * @param {boolean} shouldReplace - use replaceState or pushState\n\t * @returns {boolean} - route not found flag\n\t */\n\tfunction go(path, title, shouldReplace) {\n\t  if (hist) { // if a browser\n\t    path = base + normalize(path)\n\t    title = title || doc.title\n\t    // browsers ignores the second parameter `title`\n\t    shouldReplace\n\t      ? hist.replaceState(null, title, path)\n\t      : hist.pushState(null, title, path)\n\t    // so we need to set it manually\n\t    doc.title = title\n\t    routeFound = false\n\t    emit()\n\t    return routeFound\n\t  }\n\t\n\t  // Server-side usage: directly execute handlers for the path\n\t  return central[TRIGGER]('emit', getPathFromBase(path))\n\t}\n\t\n\t/**\n\t * Go to path or set action\n\t * a single string:                go there\n\t * two strings:                    go there with setting a title\n\t * two strings and boolean:        replace history with setting a title\n\t * a single function:              set an action on the default route\n\t * a string/RegExp and a function: set an action on the route\n\t * @param {(string|function)} first - path / action / filter\n\t * @param {(string|RegExp|function)} second - title / action\n\t * @param {boolean} third - replace flag\n\t */\n\tprot.m = function(first, second, third) {\n\t  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n\t  else if (second) this.r(first, second)\n\t  else this.r('@', first)\n\t}\n\t\n\t/**\n\t * Stop routing\n\t */\n\tprot.s = function() {\n\t  this.off('*')\n\t  this.$ = []\n\t}\n\t\n\t/**\n\t * Emit\n\t * @param {string} path - path\n\t */\n\tprot.e = function(path) {\n\t  this.$.concat('@').some(function(filter) {\n\t    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n\t    if (typeof args != 'undefined') {\n\t      this[TRIGGER].apply(null, [filter].concat(args))\n\t      return routeFound = true // exit from loop\n\t    }\n\t  }, this)\n\t}\n\t\n\t/**\n\t * Register route\n\t * @param {string} filter - filter for matching to url\n\t * @param {function} action - action to register\n\t */\n\tprot.r = function(filter, action) {\n\t  if (filter != '@') {\n\t    filter = '/' + normalize(filter)\n\t    this.$.push(filter)\n\t  }\n\t  this.on(filter, action)\n\t}\n\t\n\tvar mainRouter = new Router()\n\tvar route = mainRouter.m.bind(mainRouter)\n\t\n\t/**\n\t * Create a sub router\n\t * @returns {function} the method of a new Router object\n\t */\n\troute.create = function() {\n\t  var newSubRouter = new Router()\n\t  // assign sub-router's main method\n\t  var router = newSubRouter.m.bind(newSubRouter)\n\t  // stop only this sub-router\n\t  router.stop = newSubRouter.s.bind(newSubRouter)\n\t  return router\n\t}\n\t\n\t/**\n\t * Set the base of url\n\t * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n\t */\n\troute.base = function(arg) {\n\t  base = arg || '#'\n\t  current = getPathFromBase() // recalculate current path\n\t}\n\t\n\t/** Exec routing right now **/\n\troute.exec = function() {\n\t  emit(true)\n\t}\n\t\n\t/**\n\t * Replace the default router to yours\n\t * @param {function} fn - your parser function\n\t * @param {function} fn2 - your secondParser function\n\t */\n\troute.parser = function(fn, fn2) {\n\t  if (!fn && !fn2) {\n\t    // reset parser for testing...\n\t    parser = DEFAULT_PARSER\n\t    secondParser = DEFAULT_SECOND_PARSER\n\t  }\n\t  if (fn) parser = fn\n\t  if (fn2) secondParser = fn2\n\t}\n\t\n\t/**\n\t * Helper function to get url query as an object\n\t * @returns {object} parsed query\n\t */\n\troute.query = function() {\n\t  var q = {}\n\t  var href = loc.href || current\n\t  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n\t  return q\n\t}\n\t\n\t/** Stop routing **/\n\troute.stop = function () {\n\t  if (started) {\n\t    if (win) {\n\t      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n\t      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n\t      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n\t    }\n\t    central[TRIGGER]('stop')\n\t    started = false\n\t  }\n\t}\n\t\n\t/**\n\t * Start routing\n\t * @param {boolean} autoExec - automatically exec after starting if true\n\t */\n\troute.start = function (autoExec) {\n\t  if (!started) {\n\t    if (win) {\n\t      if (document.readyState == 'complete') start(autoExec)\n\t      // the timeout is needed to solve\n\t      // a weird safari bug https://github.com/riot/route/issues/33\n\t      else win[ADD_EVENT_LISTENER]('load', function() {\n\t        setTimeout(function() { start(autoExec) }, 1)\n\t      })\n\t    }\n\t    started = true\n\t  }\n\t}\n\t\n\t/** Prepare the router **/\n\troute.base()\n\troute.parser()\n\t\n\triot.route = route\n\t})(riot)\n\t/* istanbul ignore next */\n\t\n\t/**\n\t * The riot template engine\n\t * @version v2.3.22\n\t */\n\t\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }'\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ]\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) bp = _cache\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) return _pairs\n\t\n\t    var arr = pair.split(' ')\n\t\n\t    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n\t    arr[6] = _rewrite(_pairs[6], arr)\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n\t    arr[8] = pair\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) _bp = _cache\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6]\n\t\n\t    isexpr = start = re.lastIndex = 0\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      pos = match.index\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n\t          continue\n\t        }\n\t        if (!match[3]) {\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos))\n\t        start = re.lastIndex\n\t        re = _bp[6 + (isexpr ^= 1)]\n\t        re.lastIndex = start\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start))\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'))\n\t      } else {\n\t        parts.push(s)\n\t      }\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch]\n\t\n\t      recch.lastIndex = ix\n\t      ix = 1\n\t      while ((match = recch.exec(s))) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) break\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  }\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  }\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9])\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  }\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  }\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair)\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite\n\t      _cache[9] = _regex(_pairs[9])\n\t    }\n\t    cachedBrackets = pair\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b\n\t\n\t    o = o || {}\n\t    b = o.brackets\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    })\n\t    _settings = o\n\t    _reset(b)\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  })\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n\t  _brackets.set = _reset\n\t\n\t  _brackets.R_STRINGS = R_STRINGS\n\t  _brackets.R_MLCOMMS = R_MLCOMMS\n\t  _brackets.S_QBLOCKS = S_QBLOCKS\n\t\n\t  return _brackets\n\t\n\t})()\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {}\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) return str\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.haveRaw = brackets.hasRaw\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys\n\t\n\t  _tmpl.errorHandler = null\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    if (_tmpl.errorHandler) {\n\t\n\t      err.riotData = {\n\t        tagName: ctx && ctx.root && ctx.root.tagName,\n\t        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t      }\n\t      _tmpl.errorHandler(err)\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str)\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\t\n\t    return new Function('E', expr + ';')    //eslint-disable-line no-new-func\n\t  }\n\t\n\t  var\n\t    CH_IDEXPR = '\\u2057',\n\t    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_DQUOTE = /\\u2057/g,\n\t    RE_QBMARK = /\\u2057(\\d+)~/g\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1)\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = []\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i]\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) list[j++] = expr\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")'\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr)\n\t    }\n\t\n\t    if (qstr[0]) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      })\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    }\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g\n\t\n\t        expr = RegExp.rightContext\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\t\n\t        jsb  = expr.slice(0, match.index)\n\t        expr = RegExp.rightContext\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key)\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch]\n\t\n\t      ir.lastIndex = re.lastIndex\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) ++lv\n\t        else if (!--lv) break\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n\t          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos))\n\t        }\n\t      }\n\t      return match\n\t    })\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"'\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)'\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  // istanbul ignore next: compatibility fix for beta versions\n\t  _tmpl.parse = function (s) { return s }\n\t\n\t  _tmpl.version = brackets.version = 'v2.3.22'\n\t\n\t  return _tmpl\n\t\n\t})()\n\t\n\t/*\n\t  lib/browser/tag/mkdom.js\n\t\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\tvar mkdom = (function _mkdom() {\n\t  var\n\t    reHasYield  = /<yield\\b/i,\n\t    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n\t    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n\t    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig\n\t  var\n\t    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n\t    tblTags = IE_VERSION && IE_VERSION < 10\n\t      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\t\n\t  /**\n\t   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t   *\n\t   * @param   {string} templ  - The template coming from the custom tag definition\n\t   * @param   {string} [html] - HTML content that comes from the DOM element where you\n\t   *           will mount the tag, mostly the original tag in the page\n\t   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n\t   */\n\t  function _mkdom(templ, html) {\n\t    var\n\t      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n\t      tagName = match && match[1].toLowerCase(),\n\t      el = mkEl('div')\n\t\n\t    // replace all the yield tags with the tag inner html\n\t    templ = replaceYield(templ, html)\n\t\n\t    /* istanbul ignore next */\n\t    if (tblTags.test(tagName))\n\t      el = specialTags(el, templ, tagName)\n\t    else\n\t      el.innerHTML = templ\n\t\n\t    el.stub = true\n\t\n\t    return el\n\t  }\n\t\n\t  /*\n\t    Creates the root element for table or select child elements:\n\t    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t  */\n\t  function specialTags(el, templ, tagName) {\n\t    var\n\t      select = tagName[0] === 'o',\n\t      parent = select ? 'select>' : 'table>'\n\t\n\t    // trim() is important here, this ensures we don't have artifacts,\n\t    // so we can check if we have only one element inside the parent\n\t    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n\t    parent = el.firstChild\n\t\n\t    // returns the immediate parent if tr/th/td/col is the only element, if not\n\t    // returns the whole tree, as this can include additional elements\n\t    if (select) {\n\t      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n\t    } else {\n\t      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t      var tname = rootEls[tagName]\n\t      if (tname && parent.childElementCount === 1) parent = $(tname, parent)\n\t    }\n\t    return parent\n\t  }\n\t\n\t  /*\n\t    Replace the yield tag from any tag template with the innerHTML of the\n\t    original tag in the page\n\t  */\n\t  function replaceYield(templ, html) {\n\t    // do nothing if no yield\n\t    if (!reHasYield.test(templ)) return templ\n\t\n\t    // be careful with #1343 - string on the source having `$1`\n\t    var src = {}\n\t\n\t    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t      src[ref] = src[ref] || text   // preserve first definition\n\t      return ''\n\t    }).trim()\n\t\n\t    return templ\n\t      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t        return src[ref] || def || ''\n\t      })\n\t      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t        return html || def || ''\n\t      })\n\t  }\n\t\n\t  return _mkdom\n\t\n\t})()\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t */\n\tfunction unmountRedundant(items, tags) {\n\t\n\t  var i = tags.length,\n\t    j = items.length,\n\t    t\n\t\n\t  while (i > j) {\n\t    t = tags[--i]\n\t    tags.splice(i, 1)\n\t    t.unmount()\n\t  }\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @param   { Object } child - non custom loop tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(child, i) {\n\t  Object.keys(child.tags).forEach(function(tagName) {\n\t    var tag = child.tags[tagName]\n\t    if (isArray(tag))\n\t      each(tag, function (t) {\n\t        moveChildTag(t, tagName, i)\n\t      })\n\t    else\n\t      moveChildTag(tag, tagName, i)\n\t  })\n\t}\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @param { Tag } tag - the tag whose root's children will be inserted or appended\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction addVirtual(tag, src, target) {\n\t  var el = tag._root, sib\n\t  tag._virts = []\n\t  while (el) {\n\t    sib = el.nextSibling\n\t    if (target)\n\t      src.insertBefore(el, target._root)\n\t    else\n\t      src.appendChild(el)\n\t\n\t    tag._virts.push(el) // hold for unmounting\n\t    el = sib\n\t  }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @param { Tag } tag - first child reference used to start move\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t * @param { Number } len - how many child nodes to move\n\t */\n\tfunction moveVirtual(tag, src, target, len) {\n\t  var el = tag._root, sib, i = 0\n\t  for (; i < len; i++) {\n\t    sib = el.nextSibling\n\t    src.insertBefore(el, target._root)\n\t    el = sib\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { Object } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, 'each')\n\t\n\t  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n\t    tagName = getTagName(dom),\n\t    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n\t    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n\t    root = dom.parentNode,\n\t    ref = document.createTextNode(''),\n\t    child = getTag(dom),\n\t    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isVirtual = dom.tagName == 'VIRTUAL'\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr)\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  root.insertBefore(ref, dom)\n\t\n\t  // clean template code\n\t  parent.one('before-mount', function () {\n\t\n\t    // remove the original DOM node\n\t    dom.parentNode.removeChild(dom)\n\t    if (root.stub) root = parent.root\n\t\n\t  }).on('update', function () {\n\t    // get the new items collection\n\t    var items = tmpl(expr.val, parent),\n\t      // create a fragment to hold the new DOM nodes to inject in the parent tag\n\t      frag = document.createDocumentFragment()\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!isArray(items)) {\n\t      hasKeys = items || false\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, key, items[key])\n\t        }) : []\n\t    }\n\t\n\t    // loop all the new items\n\t    var i = 0,\n\t      itemsLength = items.length\n\t\n\t    for (; i < itemsLength; i++) {\n\t      // reorder only if the items are objects\n\t      var\n\t        item = items[i],\n\t        _mustReorder = mustReorder && item instanceof Object && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        pos = ~oldPos && _mustReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos]\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\t\n\t      // new tag\n\t      if (\n\t        !_mustReorder && !tag // with no-reorder we just update the old tags\n\t        ||\n\t        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n\t      ) {\n\t\n\t        tag = new Tag(impl, {\n\t          parent: parent,\n\t          isLoop: true,\n\t          hasImpl: !!__tagImpl[tagName],\n\t          root: useRoot ? root : dom.cloneNode(),\n\t          item: item\n\t        }, dom.innerHTML)\n\t\n\t        tag.mount()\n\t\n\t        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n\t        // this tag must be appended\n\t        if (i == tags.length || !tags[i]) { // fix 1581\n\t          if (isVirtual)\n\t            addVirtual(tag, frag)\n\t          else frag.appendChild(tag.root)\n\t        }\n\t        // this tag must be insert\n\t        else {\n\t          if (isVirtual)\n\t            addVirtual(tag, root, tags[i])\n\t          else root.insertBefore(tag.root, tags[i].root) // #1374 some browsers reset selected here\n\t          oldItems.splice(i, 0, item)\n\t        }\n\t\n\t        tags.splice(i, 0, tag)\n\t        pos = i // handled here so no move\n\t      } else tag.update(item, true)\n\t\n\t      // reorder the tag if it's not located in its previous position\n\t      if (\n\t        pos !== i && _mustReorder &&\n\t        tags[i] // fix 1581 unable to reproduce it in a test!\n\t      ) {\n\t        // update the DOM\n\t        if (isVirtual)\n\t          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n\t        else root.insertBefore(tag.root, tags[i].root)\n\t        // update the position attribute if it exists\n\t        if (expr.pos)\n\t          tag[expr.pos] = i\n\t        // move the old tag instance\n\t        tags.splice(i, 0, tags.splice(pos, 1)[0])\n\t        // move the old item\n\t        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) moveNestedTags(tag, i)\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag._item = item\n\t      // cache the real parent tag internally\n\t      defineProperty(tag, '_parent', parent)\n\t    }\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags)\n\t\n\t    // insert the new nodes\n\t    if (isOption) {\n\t      root.appendChild(frag)\n\t\n\t      // #1374 FireFox bug in <option selected={expression}>\n\t      if (FIREFOX && !root.multiple) {\n\t        for (var n = 0; n < root.length; n++) {\n\t          if (root[n].__riot1374) {\n\t            root.selectedIndex = n  // clear other options\n\t            delete root[n].__riot1374\n\t            break\n\t          }\n\t        }\n\t      }\n\t    }\n\t    else root.insertBefore(frag, ref)\n\t\n\t    // set the 'tags' property of the parent tag\n\t    // if child is 'undefined' it means that we don't need to set this property\n\t    // for example:\n\t    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n\t    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n\t    if (child) parent.tags[tagName] = tags\n\t\n\t    // clone the items array\n\t    oldItems = items.slice()\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = (function(_riot) {\n\t\n\t  if (!window) return { // skip injection on the server\n\t    add: function () {},\n\t    inject: function () {}\n\t  }\n\t\n\t  var styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style')\n\t    setAttr(newNode, 'type', 'text/css')\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]')\n\t    if (userNode) {\n\t      if (userNode.id) newNode.id = userNode.id\n\t      userNode.parentNode.replaceChild(newNode, userNode)\n\t    }\n\t    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\t\n\t    return newNode\n\t  })()\n\t\n\t  // Create cache and shortcut to the correct property\n\t  var cssTextProp = styleNode.styleSheet,\n\t    stylesToInject = ''\n\t\n\t  // Expose the style node in a non-modificable property\n\t  Object.defineProperty(_riot, 'styleNode', {\n\t    value: styleNode,\n\t    writable: true\n\t  })\n\t\n\t  /**\n\t   * Public api\n\t   */\n\t  return {\n\t    /**\n\t     * Save a tag style to be later injected into DOM\n\t     * @param   { String } css [description]\n\t     */\n\t    add: function(css) {\n\t      stylesToInject += css\n\t    },\n\t    /**\n\t     * Inject all previously saved tag styles into DOM\n\t     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t     */\n\t    inject: function() {\n\t      if (stylesToInject) {\n\t        if (cssTextProp) cssTextProp.cssText += stylesToInject\n\t        else styleNode.innerHTML += stylesToInject\n\t        stylesToInject = ''\n\t      }\n\t    }\n\t  }\n\t\n\t})(riot)\n\t\n\t\n\tfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t      dom.isLoop = dom.isLoop ||\n\t                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n\t                    ? 1 : 0\n\t\n\t      // custom child tag\n\t      if (childTags) {\n\t        var child = getTag(dom)\n\t\n\t        if (child && !dom.isLoop)\n\t          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n\t      }\n\t\n\t      if (!dom.isLoop || forceParsingNamed)\n\t        setNamed(dom, tag, [])\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (tmpl.hasExpr(val)) {\n\t      expressions.push(extend({ dom: dom, expr: val }, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType,\n\t      attr\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    attr = getAttr(dom, 'each')\n\t\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t        bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf, innerHTML) {\n\t\n\t  var self = riot.observable(this),\n\t    opts = inherit(conf.opts) || {},\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    hasImpl = conf.hasImpl,\n\t    item = cleanUpData(conf.item),\n\t    expressions = [],\n\t    childTags = [],\n\t    root = conf.root,\n\t    tagName = root.tagName.toLowerCase(),\n\t    attr = {},\n\t    propsInSyncWithParent = [],\n\t    dom\n\t\n\t  // only call unmount if we have a valid __tagImpl (has name property)\n\t  if (impl.name && root._tag) root._tag.unmount(true)\n\t\n\t  // not yet mounted\n\t  this.isMounted = false\n\t  root.isLoop = isLoop\n\t\n\t  // keep a reference to the tag just created\n\t  // so we will be able to mount this tag multiple times\n\t  root._tag = this\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    var val = el.value\n\t    // remember attributes with expressions only\n\t    if (tmpl.hasExpr(val)) attr[el.name] = val\n\t  })\n\t\n\t  dom = mkdom(impl.tmpl, innerHTML)\n\t\n\t  // options\n\t  function updateOpts() {\n\t    var ctx = hasImpl && isLoop ? self : parent || self\n\t\n\t    // update opts from current DOM attributes\n\t    each(root.attributes, function(el) {\n\t      var val = el.value\n\t      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n\t    })\n\t    // recover those with expressions\n\t    each(Object.keys(attr), function(name) {\n\t      opts[toCamel(name)] = tmpl(attr[name], ctx)\n\t    })\n\t  }\n\t\n\t  function normalizeData(data) {\n\t    for (var key in item) {\n\t      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n\t        self[key] = data[key]\n\t    }\n\t  }\n\t\n\t  function inheritFromParent () {\n\t    if (!self.parent || !isLoop) return\n\t    each(Object.keys(self.parent), function(k) {\n\t      // some properties must be always in sync with the parent tag\n\t      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n\t      if (typeof self[k] === T_UNDEF || mustSync) {\n\t        // track the property to keep in sync\n\t        // so we can keep it updated\n\t        if (!mustSync) propsInSyncWithParent.push(k)\n\t        self[k] = self.parent[k]\n\t      }\n\t    })\n\t  }\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @param   { Boolean } isInherited - is this update coming from a parent tag?\n\t   * @returns { self }\n\t   */\n\t  defineProperty(this, 'update', function(data, isInherited) {\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data)\n\t    // inherit properties from the parent\n\t    inheritFromParent()\n\t    // normalize the tag properties in case an item object was initially passed\n\t    if (data && isObject(item)) {\n\t      normalizeData(data)\n\t      item = data\n\t    }\n\t    extend(self, data)\n\t    updateOpts()\n\t    self.trigger('update', data)\n\t    update(expressions, self)\n\t\n\t    // the updated event will be triggered\n\t    // once the DOM will be ready and all the re-flows are completed\n\t    // this is useful if you want to get the \"real\" root properties\n\t    // 4 ex: root.offsetWidth ...\n\t    if (isInherited && self.parent)\n\t      // closes #1599\n\t      self.parent.one('updated', function() { self.trigger('updated') })\n\t    else rAF(function() { self.trigger('updated') })\n\t\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mixin', function() {\n\t    each(arguments, function(mix) {\n\t      var instance\n\t\n\t      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix()\n\t        // save the prototype to loop it afterwards\n\t        mix = mix.prototype\n\t      } else instance = mix\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(Object.getOwnPropertyNames(mix), function(key) {\n\t        // bind methods to self\n\t        if (key != 'init')\n\t          self[key] = isFunction(instance[key]) ?\n\t                        instance[key].bind(self) :\n\t                        instance[key]\n\t      })\n\t\n\t      // init method will be called automatically\n\t      if (instance.init) instance.init.bind(self)()\n\t    })\n\t    return this\n\t  })\n\t\n\t  defineProperty(this, 'mount', function() {\n\t\n\t    updateOpts()\n\t\n\t    // add global mixin\n\t    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n\t    if (globalMixin) self.mixin(globalMixin)\n\t\n\t    // initialiation\n\t    if (impl.fn) impl.fn.call(self, opts)\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t\n\t    // mount the child tags\n\t    toggle(true)\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    // it fixes also #1087\n\t    if (impl.attrs)\n\t      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n\t    if (impl.attrs || hasImpl)\n\t      parseExpressions(self.root, self, expressions)\n\t\n\t    if (!self.parent || isLoop) self.update(item)\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('before-mount')\n\t\n\t    if (isLoop && !hasImpl) {\n\t      // update the root attribute for the looped elements\n\t      root = dom.firstChild\n\t    } else {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t      if (root.stub) root = parent.root\n\t    }\n\t\n\t    defineProperty(self, 'root', root)\n\t\n\t    // parse the named dom nodes in the looped child\n\t    // adding them to the parent as well\n\t    if (isLoop)\n\t      parseNamedElements(self.root, self.parent, null, true)\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!self.parent || self.parent.isMounted) {\n\t      self.isMounted = true\n\t      self.trigger('mount')\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else self.parent.one('mount', function() {\n\t      // avoid to trigger the `mount` event for the tags\n\t      // not visible included in an if statement\n\t      if (!isInStub(self.root)) {\n\t        self.parent.isMounted = self.isMounted = true\n\t        self.trigger('mount')\n\t      }\n\t    })\n\t  })\n\t\n\t\n\t  defineProperty(this, 'unmount', function(keepRootTag) {\n\t    var el = root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __virtualDom.indexOf(self)\n\t\n\t    self.trigger('before-unmount')\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (~tagIndex)\n\t      __virtualDom.splice(tagIndex, 1)\n\t\n\t    if (p) {\n\t\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent)\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (isArray(ptag.tags[tagName]))\n\t          each(ptag.tags[tagName], function(tag, i) {\n\t            if (tag._riot_id == self._riot_id)\n\t              ptag.tags[tagName].splice(i, 1)\n\t          })\n\t        else\n\t          // otherwise just delete the tag instance\n\t          ptag.tags[tagName] = undefined\n\t      }\n\t\n\t      else\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t\n\t      if (!keepRootTag)\n\t        p.removeChild(el)\n\t      else {\n\t        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n\t        remAttr(p, RIOT_TAG_IS)\n\t        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0\n\t      }\n\t\n\t    }\n\t\n\t    if (this._virts) {\n\t      each(this._virts, function(v) {\n\t        if (v.parentNode) v.parentNode.removeChild(v)\n\t      })\n\t    }\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    self.isMounted = false\n\t    delete root._tag\n\t\n\t  })\n\t\n\t  // proxy function to bind updates\n\t  // dispatched from a parent tag\n\t  function onChildUpdate(data) { self.update(data, true) }\n\t\n\t  function toggle(isMount) {\n\t\n\t    // mount/unmount children\n\t    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (!parent) return\n\t    var evt = isMount ? 'on' : 'off'\n\t\n\t    // the loop tags will be always in sync with the parent automatically\n\t    if (isLoop)\n\t      parent[evt]('unmount', self.unmount)\n\t    else {\n\t      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)\n\t    }\n\t  }\n\t\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, childTags)\n\t\n\t}\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    var ptag = tag._parent,\n\t      item = tag._item,\n\t      el\n\t\n\t    if (!item)\n\t      while (ptag && !item) {\n\t        item = ptag._item\n\t        ptag = ptag._parent\n\t      }\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t\n\t    // override the event properties\n\t    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n\t    if (isWritable(e, 'target')) e.target = e.srcElement\n\t    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\t\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      if (e.preventDefault) e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    if (!e.preventUpdate) {\n\t      el = item ? getImmediateCustomParentTag(ptag) : tag\n\t      el.update()\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\t\n\t/**\n\t * Insert a DOM node replacing another one (used by if- attribute)\n\t * @param   { Object } root - parent node\n\t * @param   { Object } node - node replaced\n\t * @param   { Object } before - node added\n\t */\n\tfunction insertTo(root, node, before) {\n\t  if (!root) return\n\t  root.insertBefore(before, node)\n\t  root.removeChild(node)\n\t}\n\t\n\t/**\n\t * Update the expressions in a Tag instance\n\t * @param   { Array } expressions - expression that must be re evaluated\n\t * @param   { Tag } tag - tag instance\n\t */\n\tfunction update(expressions, tag) {\n\t\n\t  each(expressions, function(expr, i) {\n\t\n\t    var dom = expr.dom,\n\t      attrName = expr.attr,\n\t      value = tmpl(expr.expr, tag),\n\t      parent = expr.dom.parentNode\n\t\n\t    if (expr.bool) {\n\t      value = !!value\n\t    } else if (value == null) {\n\t      value = ''\n\t    }\n\t\n\t    // #1638: regression of #1612, update the dom only if the value of the\n\t    // expression was changed\n\t    if (expr.value === value) {\n\t      return\n\t    }\n\t    expr.value = value\n\t\n\t    // textarea and text nodes has no attribute name\n\t    if (!attrName) {\n\t      // about #815 w/o replace: the browser converts the value to a string,\n\t      // the comparison by \"==\" does too, but not in the server\n\t      value += ''\n\t      // test for parent avoids error with invalid assignment to nodeValue\n\t      if (parent) {\n\t        if (parent.tagName === 'TEXTAREA') {\n\t          parent.value = value                    // #1113\n\t          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n\t        }                                         // will be available on 'updated'\n\t        else dom.nodeValue = value\n\t      }\n\t      return\n\t    }\n\t\n\t    // ~~#1612: look for changes in dom.value when updating the value~~\n\t    if (attrName === 'value') {\n\t      dom.value = value\n\t      return\n\t    }\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attrName)\n\t\n\t    // event handler\n\t    if (isFunction(value)) {\n\t      setEventHandler(attrName, value, dom, tag)\n\t\n\t    // if- conditional\n\t    } else if (attrName == 'if') {\n\t      var stub = expr.stub,\n\t        add = function() { insertTo(stub.parentNode, stub, dom) },\n\t        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        if (stub) {\n\t          add()\n\t          dom.inStub = false\n\t          // avoid to trigger the mount event if the tags is not visible yet\n\t          // maybe we can optimize this avoiding to mount the tag at all\n\t          if (!isInStub(dom)) {\n\t            walk(dom, function(el) {\n\t              if (el._tag && !el._tag.isMounted)\n\t                el._tag.isMounted = !!el._tag.trigger('mount')\n\t            })\n\t          }\n\t        }\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        // if the parentNode is defined we can easily replace the tag\n\t        if (dom.parentNode)\n\t          remove()\n\t        // otherwise we need to wait the updated event\n\t        else (tag.parent || tag).one('updated', remove)\n\t\n\t        dom.inStub = true\n\t      }\n\t    // show / hide\n\t    } else if (attrName === 'show') {\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    } else if (attrName === 'hide') {\n\t      dom.style.display = value ? 'none' : ''\n\t\n\t    } else if (expr.bool) {\n\t      dom[attrName] = value\n\t      if (value) setAttr(dom, attrName, attrName)\n\t      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {\n\t        dom.__riot1374 = value   // #1374\n\t      }\n\t\n\t    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n\t      // <img src=\"{ expr }\">\n\t      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n\t        attrName = attrName.slice(RIOT_PREFIX.length)\n\t      }\n\t      setAttr(dom, attrName, value)\n\t    }\n\t\n\t  })\n\t\n\t}\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } els - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(els, fn) {\n\t  var len = els ? els.length : 0\n\t\n\t  for (var i = 0, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> current item was removed by fn during the loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is a function\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(v) {\n\t  return typeof v === T_FUNCTION || false   // avoid IE problems\n\t}\n\t\n\t/**\n\t * Detect if the argument passed is an object, exclude null.\n\t * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } v - whatever you want to pass to this function\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(v) {\n\t  return v && typeof v === T_OBJECT         // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } string - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(string) {\n\t  return string.replace(/-(\\w)/g, function(_, c) {\n\t    return c.toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  dom.setAttribute(name, val)\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||\n\t    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n\t}\n\t/**\n\t * Add a child tag to its parent into the `tags` object\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the new tag will be stored\n\t * @param   { Object } parent - tag instance where the new child tag will be included\n\t */\n\tfunction addChildTag(tag, tagName, parent) {\n\t  var cachedTag = parent.tags[tagName]\n\t\n\t  // if there are multiple children tags having the same name\n\t  if (cachedTag) {\n\t    // if the parent tags property is not yet an array\n\t    // create it adding the first cached tag\n\t    if (!isArray(cachedTag))\n\t      // don't add the same tag twice\n\t      if (cachedTag !== tag)\n\t        parent.tags[tagName] = [cachedTag]\n\t    // add the new nested tag to the array\n\t    if (!contains(parent.tags[tagName], tag))\n\t      parent.tags[tagName].push(tag)\n\t  } else {\n\t    parent.tags[tagName] = tag\n\t  }\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @param   { Object } tag - child tag instance\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tag, tagName, newPos) {\n\t  var parent = tag.parent,\n\t    tags\n\t  // no parent no move\n\t  if (!parent) return\n\t\n\t  tags = parent.tags[tagName]\n\t\n\t  if (isArray(tags))\n\t    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n\t  else addChildTag(tag, tagName, parent)\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag(child, opts, innerHTML),\n\t    tagName = getTagName(opts.root),\n\t    ptag = getImmediateCustomParentTag(parent)\n\t  // fix for the parent attribute in the looped elements\n\t  tag.parent = ptag\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag._parent = parent\n\t\n\t  // add this tag to the custom parent tag\n\t  addChildTag(tag, tagName, ptag)\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    addChildTag(tag, tagName, parent)\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = ''\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag\n\t  while (!getTag(ptag.root)) {\n\t    if (!ptag.parent) break\n\t    ptag = ptag.parent\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t* @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options))\n\t  return el\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom) {\n\t  var child = getTag(dom),\n\t    namedTag = getAttr(dom, 'name'),\n\t    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t\n\t  return tagName\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          src[key] = obj[key]\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } arr - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } Does 'arr' contain 'item'?\n\t */\n\tfunction contains(arr, item) {\n\t  return ~arr.indexOf(item)\n\t}\n\t\n\t/**\n\t * Check whether an object is a kind of array\n\t * @param   { * } a - anything\n\t * @returns {Boolean} is 'a' an array?\n\t */\n\tfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\t\n\t/**\n\t * Detect whether a property of an object could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } is this property writable?\n\t */\n\tfunction isWritable(obj, key) {\n\t  var props = Object.getOwnPropertyDescriptor(obj, key)\n\t  return typeof obj[key] === T_UNDEF || props && props.writable\n\t}\n\t\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n\t    return data\n\t\n\t  var o = {}\n\t  for (var key in data) {\n\t    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n\t      o[key] = data[key]\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t */\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    // stop the recursion\n\t    if (fn(dom) === false) return\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttributes(html, fn) {\n\t  var m,\n\t    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\t\n\t  while (m = re.exec(html)) {\n\t    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n\t * @param   { Object }  dom - DOM node we want to parse\n\t * @returns { Boolean } -\n\t */\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub) return true\n\t    dom = dom.parentNode\n\t  }\n\t  return false\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name) {\n\t  return document.createElement(name)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Simple object prototypal inheritance\n\t * @param   { Object } parent - parent object\n\t * @returns { Object } child instance\n\t */\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t\n\t/**\n\t * Get the name property needed to identify a DOM node in riot\n\t * @param   { Object } dom - DOM node we need to parse\n\t * @returns { String | undefined } give us back a string to identify this dom node\n\t */\n\tfunction getNamedKey(dom) {\n\t  return getAttr(dom, 'id') || getAttr(dom, 'name')\n\t}\n\t\n\t/**\n\t * Set the named properties of a tag element\n\t * @param { Object } dom - DOM node we need to parse\n\t * @param { Object } parent - tag instance where the named dom element will be eventually added\n\t * @param { Array } keys - list of all the tag instance properties\n\t */\n\tfunction setNamed(dom, parent, keys) {\n\t  // get the key value we want to add to the tag instance\n\t  var key = getNamedKey(dom),\n\t    isArr,\n\t    // add the node detected to a tag instance using the named property\n\t    add = function(value) {\n\t      // avoid to override the tag properties already set\n\t      if (contains(keys, key)) return\n\t      // check whether this value is an array\n\t      isArr = isArray(value)\n\t      // if the key was never set\n\t      if (!value)\n\t        // set it once on the tag instance\n\t        parent[key] = dom\n\t      // if it was an array and not yet set\n\t      else if (!isArr || isArr && !contains(value, dom)) {\n\t        // add the dom node into the array\n\t        if (isArr)\n\t          value.push(dom)\n\t        else\n\t          parent[key] = [value, dom]\n\t      }\n\t    }\n\t\n\t  // skip the elements with no named properties\n\t  if (!key) return\n\t\n\t  // check whether this key has been already evaluated\n\t  if (tmpl.hasExpr(key))\n\t    // wait the first updated event only once\n\t    parent.one('mount', function() {\n\t      key = getNamedKey(dom)\n\t      add(parent[key])\n\t    })\n\t  else\n\t    add(parent[key])\n\t\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } src - source string\n\t * @param   { String } str - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(src, str) {\n\t  return src.slice(0, str.length) === str\n\t}\n\t\n\t/**\n\t * requestAnimationFrame function\n\t * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n\t */\n\tvar rAF = (function (w) {\n\t  var raf = w.requestAnimationFrame    ||\n\t            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\t\n\t  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n\t    var lastTime = 0\n\t\n\t    raf = function (cb) {\n\t      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n\t      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n\t    }\n\t  }\n\t  return raf\n\t\n\t})(window || {})\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = __tagImpl[tagName],\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\t\n\t  // clear the inner html\n\t  root.innerHTML = ''\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n\t  }\n\t\n\t  return tag\n\t}\n\t/**\n\t * Riot public api\n\t */\n\t\n\t// share methods for other riot parts, e.g. compiler\n\triot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t/**\n\t * Create a mixin that could be globally shared across all the tags\n\t */\n\triot.mixin = (function() {\n\t  var mixins = {}\n\t\n\t  /**\n\t   * Create/Return a mixin by its name\n\t   * @param   { String } name - mixin name (global mixin if missing)\n\t   * @param   { Object } mixin - mixin logic\n\t   * @returns { Object } the mixin logic\n\t   */\n\t  return function(name, mixin) {\n\t    if (isObject(name)) {\n\t      mixin = name\n\t      mixins[GLOBAL_MIXIN] = extend(mixins[GLOBAL_MIXIN] || {}, mixin)\n\t      return\n\t    }\n\t\n\t    if (!mixin) return mixins[name]\n\t    mixins[name] = mixin\n\t  }\n\t\n\t})()\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag = function(name, html, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css\n\t      css = ''\n\t    } else attrs = ''\n\t  }\n\t  if (css) {\n\t    if (isFunction(css)) fn = css\n\t    else styleManager.add(css)\n\t  }\n\t  name = name.toLowerCase()\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   html - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\triot.tag2 = function(name, html, css, attrs, fn) {\n\t  if (css) styleManager.add(css)\n\t  //if (bpair) riot.settings.brackets = bpair\n\t  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { String } selector - tag DOM selector\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\triot.mount = function(selector, tagName, opts) {\n\t\n\t  var els,\n\t    allTags,\n\t    tags = []\n\t\n\t  // helper functions\n\t\n\t  function addRiotTags(arr) {\n\t    var list = ''\n\t    each(arr, function (e) {\n\t      if (!/[^-\\w]/.test(e)) {\n\t        e = e.trim().toLowerCase()\n\t        list += ',[' + RIOT_TAG_IS + '=\"' + e + '\"],[' + RIOT_TAG + '=\"' + e + '\"]'\n\t      }\n\t    })\n\t    return list\n\t  }\n\t\n\t  function selectAllTags() {\n\t    var keys = Object.keys(__tagImpl)\n\t    return keys + addRiotTags(keys)\n\t  }\n\t\n\t  function pushTags(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName\n\t        setAttr(root, RIOT_TAG_IS, tagName)\n\t        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0\n\t      }\n\t      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\t\n\t      if (tag) tags.push(tag)\n\t    } else if (root.length) {\n\t      each(root, pushTags)   // assume nodeList\n\t    }\n\t  }\n\t\n\t  // ----- mount code -----\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject()\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName\n\t    tagName = 0\n\t  }\n\t\n\t  // crawl the DOM to find the tag\n\t  if (typeof selector === T_STRING) {\n\t    if (selector === '*')\n\t      // select all the tags registered\n\t      // and also the tags found with the riot-tag attribute set\n\t      selector = allTags = selectAllTags()\n\t    else\n\t      // or just the ones named like the selector\n\t      selector += addRiotTags(selector.split(/, */))\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    els = selector ? $$(selector) : []\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    els = selector\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectAllTags()\n\t    // if the root els it's just a single tag\n\t    if (els.tagName)\n\t      els = $$(tagName, els)\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = []\n\t      each(els, function (_el) {\n\t        nodeList.push($$(tagName, _el))\n\t      })\n\t      els = nodeList\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0\n\t  }\n\t\n\t  pushTags(els)\n\t\n\t  return tags\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\triot.update = function() {\n\t  return each(__virtualDom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t/**\n\t * Export the Virtual DOM\n\t */\n\triot.vdom = __virtualDom\n\t\n\t/**\n\t * Export the Tag constructor\n\t */\n\triot.Tag = Tag\n\t  // support CommonJS, AMD & browser\n\t  /* istanbul ignore next */\n\t  if (typeof exports === T_OBJECT)\n\t    module.exports = riot\n\t  else if (\"function\" === T_FUNCTION && typeof __webpack_require__(/*! !webpack amd options */ 22) !== T_UNDEF)\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return riot }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : void 0);\n\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */\n/*!**********************************************!*\\\n  !*** ./~/css-loader!./src/css/tacit.min.css ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 13)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"th{font-weight:600}td,th{border-bottom:1.08px solid #ccc;padding:14.85px 18px}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{display:block;max-width:100%;overflow-x:auto}button,input,select,textarea{display:block;padding:9.9px}label{display:block;margin-bottom:14.76px}button,input[type=reset],input[type=submit]{background:#f2f2f2;border-radius:3.6px;color:#8c8c8c;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.525px 23.4px;text-align:center}button:hover,input[type=reset]:hover,input[type=submit]:hover{background:#d9d9d9;color:#000}button[disabled],input[type=reset][disabled],input[type=submit][disabled]{background:#e6e6e6;color:#b3b3b3}button[type=submit],input[type=submit]{background:#367ac3;color:#fff}button[type=submit]:hover,input[type=submit]:hover{background:#255587;color:#bfbfbf}input[type=color],input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=file],input[type=month],input[type=number],input[type=password],input[type=phone],input[type=range],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],input[type=week],select,textarea{border:1px solid #ccc;margin-bottom:18px;padding:5.4px 6.3px}input[type=checkbox],input[type=radio]{float:left;line-height:36px;margin-right:9px;margin-top:8.1px}code,kbd,output,pre,samp,var{font-family:Menlo,Monaco,Consolas,Courier New,monospace;font-size:16.2px}pre{border-left:1.8px solid #96bbe2;line-height:25.2px;margin-top:29.7px;overflow:auto;padding-left:18px}pre code{background:none;border:0;line-height:29.7px;padding:0}code{background:#ededed;border:1.8px solid #ccc;border-radius:3.6px;display:inline-block;line-height:18px;padding:3px 6px 2px}h1,h2,h3,h4,h5,h6{color:#000;margin-bottom:18px}h1{font-size:36px;font-weight:500;margin-top:36px}h2{font-size:25.2px;font-weight:400;margin-top:27px}h3{font-size:21.6px;margin-top:21.6px}h4{font-size:18px;margin-top:18px}h5,h6{font-size:14.4px;font-weight:700;margin-top:18px;text-transform:uppercase}h6{color:#ccc}body,button,html,input,select,textarea{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}a{color:#367ac3;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #ccc}small{font-size:15.3px}em,i{font-style:italic}b,strong{font-weight:600}*{border:0;border-collapse:separate;border-spacing:0;box-sizing:border-box;margin:0;outline:0;padding:0;text-align:left;vertical-align:baseline}body,html{height:100%;width:100%}body{background:#f5f5f5;color:#1a1a1a;padding:36px}address,blockquote,dl,fieldset,figure,form,hr,ol,p,pre,table,ul{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;max-width:100%;width:900px}article{background:#fff;border:1.8px solid #d9d9d9;border-radius:7.2px;padding:43.2px}header{margin-bottom:36px}footer{margin-top:36px}nav,nav ul{text-align:center}nav ul{list-style:none;margin-left:0}nav ul li{display:inline;margin-left:9px;margin-right:9px}nav ul li:first-child{margin-left:0}nav ul li:last-child{margin-right:0}ol,ul{margin-left:29.7px}li ol,li ul{margin-bottom:0}@media (max-width:767px){article,body{padding:18px}article{border-radius:0;margin:-18px}input,select,textarea{max-width:100%}fieldset{min-width:0}section{width:auto}fieldset,x:-moz-any-link{display:table-cell}}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 13 */\n/*!**************************************!*\\\n  !*** ./~/css-loader/lib/css-base.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 14 */\n/*!*******************************************!*\\\n  !*** ./~/es6-promise/dist/es6-promise.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!\n\t * @overview es6-promise - a tiny implementation of Promises/A+.\n\t * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n\t * @license   Licensed under MIT license\n\t *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n\t * @version   3.1.2\n\t */\n\t\n\t(function() {\n\t    \"use strict\";\n\t    function lib$es6$promise$utils$$objectOrFunction(x) {\n\t      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isFunction(x) {\n\t      return typeof x === 'function';\n\t    }\n\t\n\t    function lib$es6$promise$utils$$isMaybeThenable(x) {\n\t      return typeof x === 'object' && x !== null;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$_isArray;\n\t    if (!Array.isArray) {\n\t      lib$es6$promise$utils$$_isArray = function (x) {\n\t        return Object.prototype.toString.call(x) === '[object Array]';\n\t      };\n\t    } else {\n\t      lib$es6$promise$utils$$_isArray = Array.isArray;\n\t    }\n\t\n\t    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n\t    var lib$es6$promise$asap$$len = 0;\n\t    var lib$es6$promise$asap$$vertxNext;\n\t    var lib$es6$promise$asap$$customSchedulerFn;\n\t\n\t    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n\t      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n\t      lib$es6$promise$asap$$len += 2;\n\t      if (lib$es6$promise$asap$$len === 2) {\n\t        // If len is 2, that means that we need to schedule an async flush.\n\t        // If additional callbacks are queued before the queue is flushed, they\n\t        // will be processed by this flush that we are scheduling.\n\t        if (lib$es6$promise$asap$$customSchedulerFn) {\n\t          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n\t        } else {\n\t          lib$es6$promise$asap$$scheduleFlush();\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n\t      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$setAsap(asapFn) {\n\t      lib$es6$promise$asap$$asap = asapFn;\n\t    }\n\t\n\t    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n\t    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n\t    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n\t    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\t\n\t    // test for web worker but not in IE10\n\t    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n\t      typeof importScripts !== 'undefined' &&\n\t      typeof MessageChannel !== 'undefined';\n\t\n\t    // node\n\t    function lib$es6$promise$asap$$useNextTick() {\n\t      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n\t      // see https://github.com/cujojs/when/issues/410 for details\n\t      return function() {\n\t        process.nextTick(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    // vertx\n\t    function lib$es6$promise$asap$$useVertxTimer() {\n\t      return function() {\n\t        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useMutationObserver() {\n\t      var iterations = 0;\n\t      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n\t      var node = document.createTextNode('');\n\t      observer.observe(node, { characterData: true });\n\t\n\t      return function() {\n\t        node.data = (iterations = ++iterations % 2);\n\t      };\n\t    }\n\t\n\t    // web worker\n\t    function lib$es6$promise$asap$$useMessageChannel() {\n\t      var channel = new MessageChannel();\n\t      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n\t      return function () {\n\t        channel.port2.postMessage(0);\n\t      };\n\t    }\n\t\n\t    function lib$es6$promise$asap$$useSetTimeout() {\n\t      return function() {\n\t        setTimeout(lib$es6$promise$asap$$flush, 1);\n\t      };\n\t    }\n\t\n\t    var lib$es6$promise$asap$$queue = new Array(1000);\n\t    function lib$es6$promise$asap$$flush() {\n\t      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n\t        var callback = lib$es6$promise$asap$$queue[i];\n\t        var arg = lib$es6$promise$asap$$queue[i+1];\n\t\n\t        callback(arg);\n\t\n\t        lib$es6$promise$asap$$queue[i] = undefined;\n\t        lib$es6$promise$asap$$queue[i+1] = undefined;\n\t      }\n\t\n\t      lib$es6$promise$asap$$len = 0;\n\t    }\n\t\n\t    function lib$es6$promise$asap$$attemptVertx() {\n\t      try {\n\t        var r = require;\n\t        var vertx = __webpack_require__(/*! vertx */ 25);\n\t        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n\t        return lib$es6$promise$asap$$useVertxTimer();\n\t      } catch(e) {\n\t        return lib$es6$promise$asap$$useSetTimeout();\n\t      }\n\t    }\n\t\n\t    var lib$es6$promise$asap$$scheduleFlush;\n\t    // Decide what async method to use to triggering processing of queued callbacks:\n\t    if (lib$es6$promise$asap$$isNode) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n\t    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n\t    } else if (lib$es6$promise$asap$$isWorker) {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n\t    } else if (lib$es6$promise$asap$$browserWindow === undefined && \"function\" === 'function') {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n\t    } else {\n\t      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n\t    }\n\t    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n\t      var parent = this;\n\t      var state = parent._state;\n\t\n\t      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n\t        return this;\n\t      }\n\t\n\t      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\t      var result = parent._result;\n\t\n\t      if (state) {\n\t        var callback = arguments[state - 1];\n\t        lib$es6$promise$asap$$asap(function(){\n\t          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n\t        });\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n\t      }\n\t\n\t      return child;\n\t    }\n\t    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n\t    function lib$es6$promise$promise$resolve$$resolve(object) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      if (object && typeof object === 'object' && object.constructor === Constructor) {\n\t        return object;\n\t      }\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$resolve(promise, object);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\t\n\t    function lib$es6$promise$$internal$$noop() {}\n\t\n\t    var lib$es6$promise$$internal$$PENDING   = void 0;\n\t    var lib$es6$promise$$internal$$FULFILLED = 1;\n\t    var lib$es6$promise$$internal$$REJECTED  = 2;\n\t\n\t    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$selfFulfillment() {\n\t      return new TypeError(\"You cannot resolve a promise with itself\");\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$cannotReturnOwn() {\n\t      return new TypeError('A promises callback cannot return that same promise.');\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$getThen(promise) {\n\t      try {\n\t        return promise.then;\n\t      } catch(error) {\n\t        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n\t        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n\t      try {\n\t        then.call(value, fulfillmentHandler, rejectionHandler);\n\t      } catch(e) {\n\t        return e;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n\t       lib$es6$promise$asap$$asap(function(promise) {\n\t        var sealed = false;\n\t        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t          if (thenable !== value) {\n\t            lib$es6$promise$$internal$$resolve(promise, value);\n\t          } else {\n\t            lib$es6$promise$$internal$$fulfill(promise, value);\n\t          }\n\t        }, function(reason) {\n\t          if (sealed) { return; }\n\t          sealed = true;\n\t\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\t\n\t        if (!sealed && error) {\n\t          sealed = true;\n\t          lib$es6$promise$$internal$$reject(promise, error);\n\t        }\n\t      }, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n\t      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n\t      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, thenable._result);\n\t      } else {\n\t        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n\t      if (maybeThenable.constructor === promise.constructor &&\n\t          then === lib$es6$promise$then$$default &&\n\t          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n\t        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n\t      } else {\n\t        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n\t        } else if (then === undefined) {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        } else if (lib$es6$promise$utils$$isFunction(then)) {\n\t          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n\t        } else {\n\t          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n\t        }\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$resolve(promise, value) {\n\t      if (promise === value) {\n\t        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n\t      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n\t        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n\t      } else {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publishRejection(promise) {\n\t      if (promise._onerror) {\n\t        promise._onerror(promise._result);\n\t      }\n\t\n\t      lib$es6$promise$$internal$$publish(promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$fulfill(promise, value) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t\n\t      promise._result = value;\n\t      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\t\n\t      if (promise._subscribers.length !== 0) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$reject(promise, reason) {\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\t      promise._state = lib$es6$promise$$internal$$REJECTED;\n\t      promise._result = reason;\n\t\n\t      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n\t      var subscribers = parent._subscribers;\n\t      var length = subscribers.length;\n\t\n\t      parent._onerror = null;\n\t\n\t      subscribers[length] = child;\n\t      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n\t      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\t\n\t      if (length === 0 && parent._state) {\n\t        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$publish(promise) {\n\t      var subscribers = promise._subscribers;\n\t      var settled = promise._state;\n\t\n\t      if (subscribers.length === 0) { return; }\n\t\n\t      var child, callback, detail = promise._result;\n\t\n\t      for (var i = 0; i < subscribers.length; i += 3) {\n\t        child = subscribers[i];\n\t        callback = subscribers[i + settled];\n\t\n\t        if (child) {\n\t          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n\t        } else {\n\t          callback(detail);\n\t        }\n\t      }\n\t\n\t      promise._subscribers.length = 0;\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$ErrorObject() {\n\t      this.error = null;\n\t    }\n\t\n\t    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\t\n\t    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n\t      try {\n\t        return callback(detail);\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n\t        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n\t      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n\t          value, error, succeeded, failed;\n\t\n\t      if (hasCallback) {\n\t        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\t\n\t        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n\t          failed = true;\n\t          error = value.error;\n\t          value = null;\n\t        } else {\n\t          succeeded = true;\n\t        }\n\t\n\t        if (promise === value) {\n\t          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n\t          return;\n\t        }\n\t\n\t      } else {\n\t        value = detail;\n\t        succeeded = true;\n\t      }\n\t\n\t      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n\t        // noop\n\t      } else if (hasCallback && succeeded) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      } else if (failed) {\n\t        lib$es6$promise$$internal$$reject(promise, error);\n\t      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n\t        lib$es6$promise$$internal$$fulfill(promise, value);\n\t      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n\t        lib$es6$promise$$internal$$reject(promise, value);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n\t      try {\n\t        resolver(function resolvePromise(value){\n\t          lib$es6$promise$$internal$$resolve(promise, value);\n\t        }, function rejectPromise(reason) {\n\t          lib$es6$promise$$internal$$reject(promise, reason);\n\t        });\n\t      } catch(e) {\n\t        lib$es6$promise$$internal$$reject(promise, e);\n\t      }\n\t    }\n\t\n\t    function lib$es6$promise$promise$all$$all(entries) {\n\t      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n\t    }\n\t    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n\t    function lib$es6$promise$promise$race$$race(entries) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (!lib$es6$promise$utils$$isArray(entries)) {\n\t        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n\t        return promise;\n\t      }\n\t\n\t      var length = entries.length;\n\t\n\t      function onFulfillment(value) {\n\t        lib$es6$promise$$internal$$resolve(promise, value);\n\t      }\n\t\n\t      function onRejection(reason) {\n\t        lib$es6$promise$$internal$$reject(promise, reason);\n\t      }\n\t\n\t      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n\t      }\n\t\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n\t    function lib$es6$promise$promise$reject$$reject(reason) {\n\t      /*jshint validthis:true */\n\t      var Constructor = this;\n\t      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t      lib$es6$promise$$internal$$reject(promise, reason);\n\t      return promise;\n\t    }\n\t    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\t\n\t    var lib$es6$promise$promise$$counter = 0;\n\t\n\t    function lib$es6$promise$promise$$needsResolver() {\n\t      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n\t    }\n\t\n\t    function lib$es6$promise$promise$$needsNew() {\n\t      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n\t    }\n\t\n\t    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n\t    /**\n\t      Promise objects represent the eventual result of an asynchronous operation. The\n\t      primary way of interacting with a promise is through its `then` method, which\n\t      registers callbacks to receive either a promise's eventual value or the reason\n\t      why the promise cannot be fulfilled.\n\t\n\t      Terminology\n\t      -----------\n\t\n\t      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n\t      - `thenable` is an object or function that defines a `then` method.\n\t      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n\t      - `exception` is a value that is thrown using the throw statement.\n\t      - `reason` is a value that indicates why a promise was rejected.\n\t      - `settled` the final resting state of a promise, fulfilled or rejected.\n\t\n\t      A promise can be in one of three states: pending, fulfilled, or rejected.\n\t\n\t      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n\t      state.  Promises that are rejected have a rejection reason and are in the\n\t      rejected state.  A fulfillment value is never a thenable.\n\t\n\t      Promises can also be said to *resolve* a value.  If this value is also a\n\t      promise, then the original promise's settled state will match the value's\n\t      settled state.  So a promise that *resolves* a promise that rejects will\n\t      itself reject, and a promise that *resolves* a promise that fulfills will\n\t      itself fulfill.\n\t\n\t\n\t      Basic Usage:\n\t      ------------\n\t\n\t      ```js\n\t      var promise = new Promise(function(resolve, reject) {\n\t        // on success\n\t        resolve(value);\n\t\n\t        // on failure\n\t        reject(reason);\n\t      });\n\t\n\t      promise.then(function(value) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Advanced Usage:\n\t      ---------------\n\t\n\t      Promises shine when abstracting away asynchronous interactions such as\n\t      `XMLHttpRequest`s.\n\t\n\t      ```js\n\t      function getJSON(url) {\n\t        return new Promise(function(resolve, reject){\n\t          var xhr = new XMLHttpRequest();\n\t\n\t          xhr.open('GET', url);\n\t          xhr.onreadystatechange = handler;\n\t          xhr.responseType = 'json';\n\t          xhr.setRequestHeader('Accept', 'application/json');\n\t          xhr.send();\n\t\n\t          function handler() {\n\t            if (this.readyState === this.DONE) {\n\t              if (this.status === 200) {\n\t                resolve(this.response);\n\t              } else {\n\t                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n\t              }\n\t            }\n\t          };\n\t        });\n\t      }\n\t\n\t      getJSON('/posts.json').then(function(json) {\n\t        // on fulfillment\n\t      }, function(reason) {\n\t        // on rejection\n\t      });\n\t      ```\n\t\n\t      Unlike callbacks, promises are great composable primitives.\n\t\n\t      ```js\n\t      Promise.all([\n\t        getJSON('/posts'),\n\t        getJSON('/comments')\n\t      ]).then(function(values){\n\t        values[0] // => postsJSON\n\t        values[1] // => commentsJSON\n\t\n\t        return values;\n\t      });\n\t      ```\n\t\n\t      @class Promise\n\t      @param {function} resolver\n\t      Useful for tooling.\n\t      @constructor\n\t    */\n\t    function lib$es6$promise$promise$$Promise(resolver) {\n\t      this._id = lib$es6$promise$promise$$counter++;\n\t      this._state = undefined;\n\t      this._result = undefined;\n\t      this._subscribers = [];\n\t\n\t      if (lib$es6$promise$$internal$$noop !== resolver) {\n\t        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n\t        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n\t    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n\t    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n\t    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n\t    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n\t    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n\t    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\t\n\t    lib$es6$promise$promise$$Promise.prototype = {\n\t      constructor: lib$es6$promise$promise$$Promise,\n\t\n\t    /**\n\t      The primary way of interacting with a promise is through its `then` method,\n\t      which registers callbacks to receive either a promise's eventual value or the\n\t      reason why the promise cannot be fulfilled.\n\t\n\t      ```js\n\t      findUser().then(function(user){\n\t        // user is available\n\t      }, function(reason){\n\t        // user is unavailable, and you are given the reason why\n\t      });\n\t      ```\n\t\n\t      Chaining\n\t      --------\n\t\n\t      The return value of `then` is itself a promise.  This second, 'downstream'\n\t      promise is resolved with the return value of the first promise's fulfillment\n\t      or rejection handler, or rejected if the handler throws an exception.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return user.name;\n\t      }, function (reason) {\n\t        return 'default name';\n\t      }).then(function (userName) {\n\t        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n\t        // will be `'default name'`\n\t      });\n\t\n\t      findUser().then(function (user) {\n\t        throw new Error('Found user, but still unhappy');\n\t      }, function (reason) {\n\t        throw new Error('`findUser` rejected and we're unhappy');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n\t        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n\t      });\n\t      ```\n\t      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        throw new PedagogicalException('Upstream error');\n\t      }).then(function (value) {\n\t        // never reached\n\t      }).then(function (value) {\n\t        // never reached\n\t      }, function (reason) {\n\t        // The `PedgagocialException` is propagated all the way down to here\n\t      });\n\t      ```\n\t\n\t      Assimilation\n\t      ------------\n\t\n\t      Sometimes the value you want to propagate to a downstream promise can only be\n\t      retrieved asynchronously. This can be achieved by returning a promise in the\n\t      fulfillment or rejection handler. The downstream promise will then be pending\n\t      until the returned promise is settled. This is called *assimilation*.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // The user's comments are now available\n\t      });\n\t      ```\n\t\n\t      If the assimliated promise rejects, then the downstream promise will also reject.\n\t\n\t      ```js\n\t      findUser().then(function (user) {\n\t        return findCommentsByAuthor(user);\n\t      }).then(function (comments) {\n\t        // If `findCommentsByAuthor` fulfills, we'll have the value here\n\t      }, function (reason) {\n\t        // If `findCommentsByAuthor` rejects, we'll have the reason here\n\t      });\n\t      ```\n\t\n\t      Simple Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var result;\n\t\n\t      try {\n\t        result = findResult();\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t      findResult(function(result, err){\n\t        if (err) {\n\t          // failure\n\t        } else {\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findResult().then(function(result){\n\t        // success\n\t      }, function(reason){\n\t        // failure\n\t      });\n\t      ```\n\t\n\t      Advanced Example\n\t      --------------\n\t\n\t      Synchronous Example\n\t\n\t      ```javascript\n\t      var author, books;\n\t\n\t      try {\n\t        author = findAuthor();\n\t        books  = findBooksByAuthor(author);\n\t        // success\n\t      } catch(reason) {\n\t        // failure\n\t      }\n\t      ```\n\t\n\t      Errback Example\n\t\n\t      ```js\n\t\n\t      function foundBooks(books) {\n\t\n\t      }\n\t\n\t      function failure(reason) {\n\t\n\t      }\n\t\n\t      findAuthor(function(author, err){\n\t        if (err) {\n\t          failure(err);\n\t          // failure\n\t        } else {\n\t          try {\n\t            findBoooksByAuthor(author, function(books, err) {\n\t              if (err) {\n\t                failure(err);\n\t              } else {\n\t                try {\n\t                  foundBooks(books);\n\t                } catch(reason) {\n\t                  failure(reason);\n\t                }\n\t              }\n\t            });\n\t          } catch(error) {\n\t            failure(err);\n\t          }\n\t          // success\n\t        }\n\t      });\n\t      ```\n\t\n\t      Promise Example;\n\t\n\t      ```javascript\n\t      findAuthor().\n\t        then(findBooksByAuthor).\n\t        then(function(books){\n\t          // found books\n\t      }).catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method then\n\t      @param {Function} onFulfilled\n\t      @param {Function} onRejected\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      then: lib$es6$promise$then$$default,\n\t\n\t    /**\n\t      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n\t      as the catch block of a try/catch statement.\n\t\n\t      ```js\n\t      function findAuthor(){\n\t        throw new Error('couldn't find that author');\n\t      }\n\t\n\t      // synchronous\n\t      try {\n\t        findAuthor();\n\t      } catch(reason) {\n\t        // something went wrong\n\t      }\n\t\n\t      // async with promises\n\t      findAuthor().catch(function(reason){\n\t        // something went wrong\n\t      });\n\t      ```\n\t\n\t      @method catch\n\t      @param {Function} onRejection\n\t      Useful for tooling.\n\t      @return {Promise}\n\t    */\n\t      'catch': function(onRejection) {\n\t        return this.then(null, onRejection);\n\t      }\n\t    };\n\t    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\t    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n\t      this._instanceConstructor = Constructor;\n\t      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\t\n\t      if (Array.isArray(input)) {\n\t        this._input     = input;\n\t        this.length     = input.length;\n\t        this._remaining = input.length;\n\t\n\t        this._result = new Array(this.length);\n\t\n\t        if (this.length === 0) {\n\t          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n\t        } else {\n\t          this.length = this.length || 0;\n\t          this._enumerate();\n\t          if (this._remaining === 0) {\n\t            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n\t          }\n\t        }\n\t      } else {\n\t        lib$es6$promise$$internal$$reject(this.promise, this._validationError());\n\t      }\n\t    }\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n\t      return new Error('Array Methods must be provided an Array');\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n\t      var length  = this.length;\n\t      var input   = this._input;\n\t\n\t      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n\t        this._eachEntry(input[i], i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n\t      var c = this._instanceConstructor;\n\t      var resolve = c.resolve;\n\t\n\t      if (resolve === lib$es6$promise$promise$resolve$$default) {\n\t        var then = lib$es6$promise$$internal$$getThen(entry);\n\t\n\t        if (then === lib$es6$promise$then$$default &&\n\t            entry._state !== lib$es6$promise$$internal$$PENDING) {\n\t          this._settledAt(entry._state, i, entry._result);\n\t        } else if (typeof then !== 'function') {\n\t          this._remaining--;\n\t          this._result[i] = entry;\n\t        } else if (c === lib$es6$promise$promise$$default) {\n\t          var promise = new c(lib$es6$promise$$internal$$noop);\n\t          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n\t          this._willSettleAt(promise, i);\n\t        } else {\n\t          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\n\t        }\n\t      } else {\n\t        this._willSettleAt(resolve(entry), i);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n\t      var promise = this.promise;\n\t\n\t      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n\t        this._remaining--;\n\t\n\t        if (state === lib$es6$promise$$internal$$REJECTED) {\n\t          lib$es6$promise$$internal$$reject(promise, value);\n\t        } else {\n\t          this._result[i] = value;\n\t        }\n\t      }\n\t\n\t      if (this._remaining === 0) {\n\t        lib$es6$promise$$internal$$fulfill(promise, this._result);\n\t      }\n\t    };\n\t\n\t    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n\t      var enumerator = this;\n\t\n\t      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n\t      }, function(reason) {\n\t        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n\t      });\n\t    };\n\t    function lib$es6$promise$polyfill$$polyfill() {\n\t      var local;\n\t\n\t      if (typeof global !== 'undefined') {\n\t          local = global;\n\t      } else if (typeof self !== 'undefined') {\n\t          local = self;\n\t      } else {\n\t          try {\n\t              local = Function('return this')();\n\t          } catch (e) {\n\t              throw new Error('polyfill failed because global object is unavailable in this environment');\n\t          }\n\t      }\n\t\n\t      var P = local.Promise;\n\t\n\t      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n\t        return;\n\t      }\n\t\n\t      local.Promise = lib$es6$promise$promise$$default;\n\t    }\n\t    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\t\n\t    var lib$es6$promise$umd$$ES6Promise = {\n\t      'Promise': lib$es6$promise$promise$$default,\n\t      'polyfill': lib$es6$promise$polyfill$$default\n\t    };\n\t\n\t    /* global define:true module:true window: true */\n\t    if (\"function\" === 'function' && __webpack_require__(/*! !webpack amd define */ 21)['amd']) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module !== 'undefined' && module['exports']) {\n\t      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n\t    } else if (typeof this !== 'undefined') {\n\t      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n\t    }\n\t\n\t    lib$es6$promise$polyfill$$default();\n\t}).call(this);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/process/browser.js */ 16), (function() { return this; }()), __webpack_require__(/*! ./../../webpack/buildin/module.js */ 23)(module)))\n\n/***/ },\n/* 15 */\n/*!****************************************************!*\\\n  !*** ./~/isomorphic-fetch/fetch-npm-browserify.js ***!\n  \\****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// the whatwg-fetch polyfill installs the fetch() function\n\t// on the global object (window or self)\n\t//\n\t// Return that as the export for use in Webpack, Browserify etc.\n\t__webpack_require__(/*! whatwg-fetch */ 24);\n\tmodule.exports = self.fetch.bind(self);\n\n\n/***/ },\n/* 16 */\n/*!******************************!*\\\n  !*** ./~/process/browser.js ***!\n  \\******************************/\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 17 */\n/*!************************************************!*\\\n  !*** ./~/stackable/dist/stackable-browsify.js ***!\n  \\************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _stackable = __webpack_require__(/*! ./stackable */ 18);\n\t\n\tvar _stackable2 = _interopRequireDefault(_stackable);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\twindow.Stackable = _stackable2.default;\n\n/***/ },\n/* 18 */\n/*!***************************************!*\\\n  !*** ./~/stackable/dist/stackable.js ***!\n  \\***************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t__webpack_require__(/*! es6-promise */ 14).polyfill();\n\t__webpack_require__(/*! isomorphic-fetch */ 15);\n\t\n\tvar Stackable = function () {\n\t    function Stackable(token) {\n\t        _classCallCheck(this, Stackable);\n\t\n\t        this._token = token;\n\t        this._apiVersion = 'v1';\n\t        this._apiUrl = 'https://api.stackable.space';\n\t    }\n\t\n\t    _createClass(Stackable, [{\n\t        key: 'getContainers',\n\t        value: function getContainers(callback) {\n\t            this._get('containers', function (err, res) {\n\t                callback(err, res);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getContainer',\n\t        value: function getContainer(containerId, callback) {\n\t            this._get('containers/' + containerId, function (err, res) {\n\t                callback(err, res);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getContainerItems',\n\t        value: function getContainerItems(containerId, callback) {\n\t            this._get('containers/' + containerId + '/items', function (err, res) {\n\t                callback(err, res);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getAllItems',\n\t        value: function getAllItems(callback) {\n\t            this._get('items', function (err, res) {\n\t                callback(err, res);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getItem',\n\t        value: function getItem(itemId, callback) {\n\t            this._get('items/' + itemId, function (err, res) {\n\t                callback(err, res);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'createItem',\n\t        value: function createItem(containerId, data, callback) {\n\t            this._post('items', { containerId: containerId }, data, function (err, res) {\n\t                callback(err, res);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'updateItem',\n\t        value: function updateItem(itemId, data, callback) {\n\t            this._put('items/' + itemId, data, function (err, res) {\n\t                callback(err, res);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_get',\n\t        value: function _get(path, callback) {\n\t            var endPoint = this._apiUrl + '/' + this._apiVersion + '/' + path + '?token=' + this._token;\n\t\n\t            fetch(endPoint).then(function (response) {\n\t                if (response.status >= 400) {\n\t                    var err = {\n\t                        'message': 'There was an error with this request.'\n\t                    };\n\t                    return callback(err, false);\n\t                }\n\t                return response.json();\n\t            }).then(function (response) {\n\t                callback(false, response);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_post',\n\t        value: function _post(path, params, data, callback) {\n\t            var endPoint = this._apiUrl + '/' + this._apiVersion + '/' + path + '?token=' + this._token;\n\t\n\t            var paramsStr = '';\n\t            for (var key in params) {\n\t                if (paramsStr != '') {\n\t                    paramsStr += '&';\n\t                }\n\t                paramsStr += key + '=' + encodeURIComponent(params[key]);\n\t            }\n\t\n\t            if (paramsStr.length > 0) {\n\t                endPoint = endPoint + '&' + paramsStr;\n\t            }\n\t\n\t            fetch(endPoint, {\n\t                method: 'POST',\n\t                headers: {\n\t                    'Content-type': 'application/json'\n\t                },\n\t                body: data\n\t            }).then(function (response) {\n\t                if (response.status >= 400) {\n\t                    var err = {\n\t                        'message': 'There was an error with this request.'\n\t                    };\n\t                    return callback(err, false);\n\t                }\n\t                return response.json();\n\t            }).then(function (response) {\n\t                return callback(false, response);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_put',\n\t        value: function _put(path, data, callback) {\n\t            var endPoint = this._apiUrl + '/' + this._apiVersion + '/' + path + '?token=' + this._token;\n\t\n\t            fetch(endPoint, {\n\t                method: 'PUT',\n\t                headers: {\n\t                    'Content-type': 'application/json'\n\t                },\n\t                body: data\n\t            }).then(function (response) {\n\t                if (response.status >= 400) {\n\t                    var err = {\n\t                        'message': 'There was an error with this request.'\n\t                    };\n\t                    return callback(err, false);\n\t                }\n\t                return response.json();\n\t            }).then(function (response) {\n\t                return callback(false, response);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Stackable;\n\t}();\n\t\n\texports.default = Stackable;\n\t//if (typeof window === 'undefined') {\n\t//    //node\n\t//    module.exports = Stackable;\n\t//} else {\n\t//    //browser\n\t//    window.Stackable = Stackable;\n\t//}\n\n/***/ },\n/* 19 */\n/*!*************************************!*\\\n  !*** ./~/style-loader/addStyles.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 20 */\n/*!*******************************!*\\\n  !*** ./src/css/tacit.min.css ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./tacit.min.css */ 12);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 19)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 21 */\n/*!***************************************!*\\\n  !*** (webpack)/buildin/amd-define.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ },\n/* 22 */\n/*!****************************************!*\\\n  !*** (webpack)/buildin/amd-options.js ***!\n  \\****************************************/\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n/* 23 */\n/*!***********************************!*\\\n  !*** (webpack)/buildin/module.js ***!\n  \\***********************************/\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 24 */\n/*!*********************************!*\\\n  !*** ./~/whatwg-fetch/fetch.js ***!\n  \\*********************************/\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  var support = {\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob();\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n\t        // Only support ArrayBuffers for POST method.\n\t        // Receiving ArrayBuffers happens via Blobs, instead.\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers;\n\t  self.Request = Request;\n\t  self.Response = Response;\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request\n\t      if (Request.prototype.isPrototypeOf(input) && !init) {\n\t        request = input\n\t      } else {\n\t        request = new Request(input, init)\n\t      }\n\t\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return;\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var status = (xhr.status === 1223) ? 204 : xhr.status\n\t        if (status < 100 || status > 599) {\n\t          reject(new TypeError('Network request failed'))\n\t          return\n\t        }\n\t        var options = {\n\t          status: status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ },\n/* 25 */\n/*!***********************!*\\\n  !*** vertx (ignored) ***!\n  \\***********************/\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendor.bundle.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ec1bd3faff834bcb88c9\n **/","import './css/tacit.min.css'\nimport 'riot'\nimport 'stackable'\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/vendor.js\n **/","/* Riot v2.3.18, @license MIT */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.3.18', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n  RIOT_TAG_IS = 'data-is',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\n  // detect firefox to fix #1374\n  FIREFOX = window && !!window.InstallTrigger\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables and methods\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice,\n    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) }\n\n  // extend the object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n     * @param  { String } events - events ids\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(events, fn) {\n        if (typeof fn != 'function')  return el\n\n        onEachEvent(events, function(name, pos) {\n          (callbacks[name] = callbacks[name] || []).push(fn)\n          fn.typed = pos > 0\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given space separated list of `events` listeners\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(events, fn) {\n        if (events == '*' && !fn) callbacks = {}\n        else {\n          onEachEvent(events, function(name) {\n            if (fn) {\n              var arr = callbacks[name]\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) arr.splice(i--, 1)\n              }\n            } else delete callbacks[name]\n          })\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given space separated list of `events` and execute the `callback` at most once\n     * @param   { String } events - events ids\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(events, fn) {\n        function on() {\n          el.off(events, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(events, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to the given space separated list of `events`\n     * @param   { String } events - events ids\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(events) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns\n\n        for (var i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        onEachEvent(events, function(name) {\n\n          fns = slice.call(callbacks[name] || [], 0)\n\n          for (var i = 0, fn; fn = fns[i]; ++i) {\n            if (fn.busy) return\n            fn.busy = 1\n            fn.apply(el, fn.typed ? [name].concat(args) : args)\n            if (fns[i] !== fn) { i-- }\n            fn.busy = 0\n          }\n\n          if (callbacks['*'] && name != '*')\n            el.trigger.apply(el, ['*', name].concat(args))\n\n        })\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) {\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = typeof window != 'undefined' && window,\n  doc = typeof document != 'undefined' && document,\n  hist = win && history,\n  loc = win && (hist.location || win.location), // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  if (hist) { // if a browser\n    path = base + normalize(path)\n    title = title || doc.title\n    // browsers ignores the second parameter `title`\n    shouldReplace\n      ? hist.replaceState(null, title, path)\n      : hist.pushState(null, title, path)\n    // so we need to set it manually\n    doc.title = title\n    routeFound = false\n    emit()\n    return routeFound\n  }\n\n  // Server-side usage: directly execute handlers for the path\n  return central[TRIGGER]('emit', getPathFromBase(path))\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) go(first, second, third || false)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter)\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter)\n  return router\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  var href = loc.href || current\n  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    }\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState == 'complete') start(autoExec)\n      // the timeout is needed to solve\n      // a weird safari bug https://github.com/riot/route/issues/33\n      else win[ADD_EVENT_LISTENER]('load', function() {\n        setTimeout(function() { start(autoExec) }, 1)\n      })\n    }\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.3.22\n */\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }'\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ]\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) bp = _cache\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) return _pairs\n\n    var arr = pair.split(' ')\n\n    if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr)\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr)\n    arr[6] = _rewrite(_pairs[6], arr)\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _cache\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex)\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'))\n      } else {\n        parts.push(s)\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch]\n\n      recch.lastIndex = ix\n      ix = 1\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) break\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9])\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  }\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  }\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _cache[9] = _regex(_pairs[9])\n    }\n    cachedBrackets = pair\n  }\n\n  function _setSettings (o) {\n    var b\n\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = R_STRINGS\n  _brackets.R_MLCOMMS = R_MLCOMMS\n  _brackets.S_QBLOCKS = S_QBLOCKS\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl (str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.haveRaw = brackets.hasRaw\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr (err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str)\n\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n    return new Function('E', expr + ';')    //eslint-disable-line no-new-func\n  }\n\n  var\n    CH_IDEXPR = '\\u2057',\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")'\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    }\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch]\n\n      ir.lastIndex = re.lastIndex\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/\n\n  function _wrapExpr (expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos))\n        }\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  _tmpl.version = brackets.version = 'v2.3.22'\n\n  return _tmpl\n\n})()\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\nvar mkdom = (function _mkdom() {\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig\n  var\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n    tblTags = IE_VERSION && IE_VERSION < 10\n      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   {string} templ  - The template coming from the custom tag definition\n   * @param   {string} [html] - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.\n   */\n  function _mkdom(templ, html) {\n    var\n      match   = templ && templ.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      el = mkEl('div')\n\n    // replace all the yield tags with the tag inner html\n    templ = replaceYield(templ, html)\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      el = specialTags(el, templ, tagName)\n    else\n      el.innerHTML = templ\n\n    el.stub = true\n\n    return el\n  }\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, templ, tagName) {\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>'\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + templ.trim() + '</' + parent\n    parent = el.firstChild\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    if (select) {\n      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName]\n      if (tname && parent.childElementCount === 1) parent = $(tname, parent)\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(templ, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(templ)) return templ\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {}\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text   // preserve first definition\n      return ''\n    }).trim()\n\n    return templ\n      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n        return src[ref] || def || ''\n      })\n      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n        return html || def || ''\n      })\n  }\n\n  return _mkdom\n\n})()\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length,\n    t\n\n  while (i > j) {\n    t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root, sib\n  tag._virts = []\n  while (el) {\n    sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root, sib, i = 0\n  for (; i < len; i++) {\n    sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    var i = 0,\n      itemsLength = items.length\n\n    for (; i < itemsLength; i++) {\n      // reorder only if the items are objects\n      var\n        item = items[i],\n        _mustReorder = mustReorder && item instanceof Object && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length || !tags[i]) { // fix 1581\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root) // #1374 some browsers reset selected here\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item, true)\n\n      // reorder the tag if it's not located in its previous position\n      if (\n        pos !== i && _mustReorder &&\n        tags[i] // fix 1581 unable to reproduce it in a test!\n      ) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n    }\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) {\n      root.appendChild(frag)\n\n      // #1374 FireFox bug in <option selected={expression}>\n      if (FIREFOX && !root.multiple) {\n        for (var n = 0; n < root.length; n++) {\n          if (root[n].__riot1374) {\n            root.selectedIndex = n  // clear other options\n            delete root[n].__riot1374\n            break\n          }\n        }\n      }\n    }\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = (function(_riot) {\n\n  if (!window) return { // skip injection on the server\n    add: function () {},\n    inject: function () {}\n  }\n\n  var styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style')\n    setAttr(newNode, 'type', 'text/css')\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]')\n    if (userNode) {\n      if (userNode.id) newNode.id = userNode.id\n      userNode.parentNode.replaceChild(newNode, userNode)\n    }\n    else document.getElementsByTagName('head')[0].appendChild(newNode)\n\n    return newNode\n  })()\n\n  // Create cache and shortcut to the correct property\n  var cssTextProp = styleNode.styleSheet,\n    stylesToInject = ''\n\n  // Expose the style node in a non-modificable property\n  Object.defineProperty(_riot, 'styleNode', {\n    value: styleNode,\n    writable: true\n  })\n\n  /**\n   * Public api\n   */\n  return {\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param   { String } css [description]\n     */\n    add: function(css) {\n      stylesToInject += css\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function() {\n      if (stylesToInject) {\n        if (cssTextProp) cssTextProp.cssText += stylesToInject\n        else styleNode.innerHTML += stylesToInject\n        stylesToInject = ''\n      }\n    }\n  }\n\n})(riot)\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop ||\n                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))\n                    ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      expressions.push(extend({ dom: dom, expr: val }, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType,\n      attr\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = [],\n    dom\n\n  // only call unmount if we have a valid __tagImpl (has name property)\n  if (impl.name && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  dom = mkdom(impl.tmpl, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      var val = el.value\n      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @param   { Boolean } isInherited - is this update coming from a parent tag?\n   * @returns { self }\n   */\n  defineProperty(this, 'update', function(data, isInherited) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && isObject(item)) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n\n    // the updated event will be triggered\n    // once the DOM will be ready and all the re-flows are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    if (isInherited && self.parent)\n      // closes #1599\n      self.parent.one('updated', function() { self.trigger('updated') })\n    else rAF(function() { self.trigger('updated') })\n\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // add global mixin\n    var globalMixin = riot.mixin(GLOBAL_MIXIN)\n    if (globalMixin) self.mixin(globalMixin)\n\n    // initialiation\n    if (impl.fn) impl.fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs)\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n    if (impl.attrs || hasImpl)\n      parseExpressions(self.root, self, expressions)\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      root = dom.firstChild\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) root = parent.root\n    }\n\n    defineProperty(self, 'root', root)\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __virtualDom.indexOf(self)\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      __virtualDom.splice(tagIndex, 1)\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else {\n        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n        remAttr(p, RIOT_TAG_IS)\n        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0\n      }\n\n    }\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        if (v.parentNode) v.parentNode.removeChild(v)\n      })\n    }\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    delete root._tag\n\n  })\n\n  // proxy function to bind updates\n  // dispatched from a parent tag\n  function onChildUpdate(data) { self.update(data, true) }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (!parent) return\n    var evt = isMount ? 'on' : 'off'\n\n    // the loop tags will be always in sync with the parent automatically\n    if (isLoop)\n      parent[evt]('unmount', self.unmount)\n    else {\n      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)\n    }\n  }\n\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (!root) return\n  root.insertBefore(before, node)\n  root.removeChild(node)\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool) {\n      value = !!value\n    } else if (value == null) {\n      value = ''\n    }\n\n    // #1638: regression of #1612, update the dom only if the value of the\n    // expression was changed\n    if (expr.value === value) {\n      return\n    }\n    expr.value = value\n\n    // textarea and text nodes has no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += ''\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value                    // #1113\n          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else dom.nodeValue = value\n      }\n      return\n    }\n\n    // ~~#1612: look for changes in dom.value when updating the value~~\n    if (attrName === 'value') {\n      dom.value = value\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted)\n                el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (attrName === 'show') {\n      dom.style.display = value ? '' : 'none'\n\n    } else if (attrName === 'hide') {\n      dom.style.display = value ? 'none' : ''\n\n    } else if (expr.bool) {\n      dom[attrName] = value\n      if (value) setAttr(dom, attrName, attrName)\n      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {\n        dom.__riot1374 = value   // #1374\n      }\n\n    } else if (value === 0 || value && typeof value !== T_OBJECT) {\n      // <img src=\"{ expr }\">\n      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n        attrName = attrName.slice(RIOT_PREFIX.length)\n      }\n      setAttr(dom, attrName, value)\n    }\n\n  })\n\n}\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  var len = els ? els.length : 0\n\n  for (var i = 0, el; i < len; i++) {\n    el = els[i]\n    // return false -> current item was removed by fn during the loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Detect if the argument passed is an object, exclude null.\n * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isObject(v) {\n  return v && typeof v === T_OBJECT         // typeof null is 'object'\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||\n    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))\n    return data\n\n  var o = {}\n  for (var key in data) {\n    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n      o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    isArr,\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('mount', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * requestAnimationFrame function\n * Adapted from https://gist.github.com/paulirish/1579671, license MIT\n */\nvar rAF = (function (w) {\n  var raf = w.requestAnimationFrame    ||\n            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame\n\n  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6\n    var lastTime = 0\n\n    raf = function (cb) {\n      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)\n      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)\n    }\n  }\n  return raf\n\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {}\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String } name - mixin name (global mixin if missing)\n   * @param   { Object } mixin - mixin logic\n   * @returns { Object } the mixin logic\n   */\n  return function(name, mixin) {\n    if (isObject(name)) {\n      mixin = name\n      mixins[GLOBAL_MIXIN] = extend(mixins[GLOBAL_MIXIN] || {}, mixin)\n      return\n    }\n\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else styleManager.add(css)\n  }\n  name = name.toLowerCase()\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn) {\n  if (css) styleManager.add(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      if (!/[^-\\w]/.test(e)) {\n        e = e.trim().toLowerCase()\n        list += ',[' + RIOT_TAG_IS + '=\"' + e + '\"],[' + RIOT_TAG + '=\"' + e + '\"]'\n      }\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName\n        setAttr(root, RIOT_TAG_IS, tagName)\n        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0\n      }\n      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length) {\n      each(root, pushTags)   // assume nodeList\n    }\n  }\n\n  // ----- mount code -----\n\n  // inject styles into DOM\n  styleManager.inject()\n\n  if (isObject(tagName)) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(/, */))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  pushTags(els)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Virtual DOM\n */\nriot.vdom = __virtualDom\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"th{font-weight:600}td,th{border-bottom:1.08px solid #ccc;padding:14.85px 18px}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{display:block;max-width:100%;overflow-x:auto}button,input,select,textarea{display:block;padding:9.9px}label{display:block;margin-bottom:14.76px}button,input[type=reset],input[type=submit]{background:#f2f2f2;border-radius:3.6px;color:#8c8c8c;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.525px 23.4px;text-align:center}button:hover,input[type=reset]:hover,input[type=submit]:hover{background:#d9d9d9;color:#000}button[disabled],input[type=reset][disabled],input[type=submit][disabled]{background:#e6e6e6;color:#b3b3b3}button[type=submit],input[type=submit]{background:#367ac3;color:#fff}button[type=submit]:hover,input[type=submit]:hover{background:#255587;color:#bfbfbf}input[type=color],input[type=date],input[type=datetime-local],input[type=datetime],input[type=email],input[type=file],input[type=month],input[type=number],input[type=password],input[type=phone],input[type=range],input[type=search],input[type=tel],input[type=text],input[type=time],input[type=url],input[type=week],select,textarea{border:1px solid #ccc;margin-bottom:18px;padding:5.4px 6.3px}input[type=checkbox],input[type=radio]{float:left;line-height:36px;margin-right:9px;margin-top:8.1px}code,kbd,output,pre,samp,var{font-family:Menlo,Monaco,Consolas,Courier New,monospace;font-size:16.2px}pre{border-left:1.8px solid #96bbe2;line-height:25.2px;margin-top:29.7px;overflow:auto;padding-left:18px}pre code{background:none;border:0;line-height:29.7px;padding:0}code{background:#ededed;border:1.8px solid #ccc;border-radius:3.6px;display:inline-block;line-height:18px;padding:3px 6px 2px}h1,h2,h3,h4,h5,h6{color:#000;margin-bottom:18px}h1{font-size:36px;font-weight:500;margin-top:36px}h2{font-size:25.2px;font-weight:400;margin-top:27px}h3{font-size:21.6px;margin-top:21.6px}h4{font-size:18px;margin-top:18px}h5,h6{font-size:14.4px;font-weight:700;margin-top:18px;text-transform:uppercase}h6{color:#ccc}body,button,html,input,select,textarea{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:18px;font-stretch:normal;font-style:normal;font-weight:300;line-height:29.7px}a{color:#367ac3;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #ccc}small{font-size:15.3px}em,i{font-style:italic}b,strong{font-weight:600}*{border:0;border-collapse:separate;border-spacing:0;box-sizing:border-box;margin:0;outline:0;padding:0;text-align:left;vertical-align:baseline}body,html{height:100%;width:100%}body{background:#f5f5f5;color:#1a1a1a;padding:36px}address,blockquote,dl,fieldset,figure,form,hr,ol,p,pre,table,ul{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;max-width:100%;width:900px}article{background:#fff;border:1.8px solid #d9d9d9;border-radius:7.2px;padding:43.2px}header{margin-bottom:36px}footer{margin-top:36px}nav,nav ul{text-align:center}nav ul{list-style:none;margin-left:0}nav ul li{display:inline;margin-left:9px;margin-right:9px}nav ul li:first-child{margin-left:0}nav ul li:last-child{margin-right:0}ol,ul{margin-left:29.7px}li ol,li ul{margin-bottom:0}@media (max-width:767px){article,body{padding:18px}article{border-radius:0;margin:-18px}input,select,textarea{max-width:100%}fieldset{min-width:0}section{width:auto}fieldset,x:-moz-any-link{display:table-cell}}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/css/tacit.min.css\n ** module id = 12\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 13\n ** module chunks = 0\n **/","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.1.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n      var parent = this;\n      var state = parent._state;\n\n      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n        return this;\n      }\n\n      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n      var result = parent._result;\n\n      if (state) {\n        var callback = arguments[state - 1];\n        lib$es6$promise$asap$$asap(function(){\n          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n        });\n      } else {\n        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n      }\n\n      return child;\n    }\n    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n      if (maybeThenable.constructor === promise.constructor &&\n          then === lib$es6$promise$then$$default &&\n          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: lib$es6$promise$then$$default,\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      this._instanceConstructor = Constructor;\n      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (Array.isArray(input)) {\n        this._input     = input;\n        this.length     = input.length;\n        this._remaining = input.length;\n\n        this._result = new Array(this.length);\n\n        if (this.length === 0) {\n          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n        } else {\n          this.length = this.length || 0;\n          this._enumerate();\n          if (this._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(this.promise, this._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var length  = this.length;\n      var input   = this._input;\n\n      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        this._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var c = this._instanceConstructor;\n      var resolve = c.resolve;\n\n      if (resolve === lib$es6$promise$promise$resolve$$default) {\n        var then = lib$es6$promise$$internal$$getThen(entry);\n\n        if (then === lib$es6$promise$then$$default &&\n            entry._state !== lib$es6$promise$$internal$$PENDING) {\n          this._settledAt(entry._state, i, entry._result);\n        } else if (typeof then !== 'function') {\n          this._remaining--;\n          this._result[i] = entry;\n        } else if (c === lib$es6$promise$promise$$default) {\n          var promise = new c(lib$es6$promise$$internal$$noop);\n          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n          this._willSettleAt(promise, i);\n        } else {\n          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\n        }\n      } else {\n        this._willSettleAt(resolve(entry), i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var promise = this.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        this._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          this._result[i] = value;\n        }\n      }\n\n      if (this._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, this._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/es6-promise/dist/es6-promise.js\n ** module id = 14\n ** module chunks = 0\n **/","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isomorphic-fetch/fetch-npm-browserify.js\n ** module id = 15\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nvar _stackable = require('./stackable');\n\nvar _stackable2 = _interopRequireDefault(_stackable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.Stackable = _stackable2.default;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stackable/dist/stackable-browsify.js\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nrequire('es6-promise').polyfill();\nrequire('isomorphic-fetch');\n\nvar Stackable = function () {\n    function Stackable(token) {\n        _classCallCheck(this, Stackable);\n\n        this._token = token;\n        this._apiVersion = 'v1';\n        this._apiUrl = 'https://api.stackable.space';\n    }\n\n    _createClass(Stackable, [{\n        key: 'getContainers',\n        value: function getContainers(callback) {\n            this._get('containers', function (err, res) {\n                callback(err, res);\n            });\n        }\n    }, {\n        key: 'getContainer',\n        value: function getContainer(containerId, callback) {\n            this._get('containers/' + containerId, function (err, res) {\n                callback(err, res);\n            });\n        }\n    }, {\n        key: 'getContainerItems',\n        value: function getContainerItems(containerId, callback) {\n            this._get('containers/' + containerId + '/items', function (err, res) {\n                callback(err, res);\n            });\n        }\n    }, {\n        key: 'getAllItems',\n        value: function getAllItems(callback) {\n            this._get('items', function (err, res) {\n                callback(err, res);\n            });\n        }\n    }, {\n        key: 'getItem',\n        value: function getItem(itemId, callback) {\n            this._get('items/' + itemId, function (err, res) {\n                callback(err, res);\n            });\n        }\n    }, {\n        key: 'createItem',\n        value: function createItem(containerId, data, callback) {\n            this._post('items', { containerId: containerId }, data, function (err, res) {\n                callback(err, res);\n            });\n        }\n    }, {\n        key: 'updateItem',\n        value: function updateItem(itemId, data, callback) {\n            this._put('items/' + itemId, data, function (err, res) {\n                callback(err, res);\n            });\n        }\n    }, {\n        key: '_get',\n        value: function _get(path, callback) {\n            var endPoint = this._apiUrl + '/' + this._apiVersion + '/' + path + '?token=' + this._token;\n\n            fetch(endPoint).then(function (response) {\n                if (response.status >= 400) {\n                    var err = {\n                        'message': 'There was an error with this request.'\n                    };\n                    return callback(err, false);\n                }\n                return response.json();\n            }).then(function (response) {\n                callback(false, response);\n            });\n        }\n    }, {\n        key: '_post',\n        value: function _post(path, params, data, callback) {\n            var endPoint = this._apiUrl + '/' + this._apiVersion + '/' + path + '?token=' + this._token;\n\n            var paramsStr = '';\n            for (var key in params) {\n                if (paramsStr != '') {\n                    paramsStr += '&';\n                }\n                paramsStr += key + '=' + encodeURIComponent(params[key]);\n            }\n\n            if (paramsStr.length > 0) {\n                endPoint = endPoint + '&' + paramsStr;\n            }\n\n            fetch(endPoint, {\n                method: 'POST',\n                headers: {\n                    'Content-type': 'application/json'\n                },\n                body: data\n            }).then(function (response) {\n                if (response.status >= 400) {\n                    var err = {\n                        'message': 'There was an error with this request.'\n                    };\n                    return callback(err, false);\n                }\n                return response.json();\n            }).then(function (response) {\n                return callback(false, response);\n            });\n        }\n    }, {\n        key: '_put',\n        value: function _put(path, data, callback) {\n            var endPoint = this._apiUrl + '/' + this._apiVersion + '/' + path + '?token=' + this._token;\n\n            fetch(endPoint, {\n                method: 'PUT',\n                headers: {\n                    'Content-type': 'application/json'\n                },\n                body: data\n            }).then(function (response) {\n                if (response.status >= 400) {\n                    var err = {\n                        'message': 'There was an error with this request.'\n                    };\n                    return callback(err, false);\n                }\n                return response.json();\n            }).then(function (response) {\n                return callback(false, response);\n            });\n        }\n    }]);\n\n    return Stackable;\n}();\n\nexports.default = Stackable;\n//if (typeof window === 'undefined') {\n//    //node\n//    module.exports = Stackable;\n//} else {\n//    //browser\n//    window.Stackable = Stackable;\n//}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stackable/dist/stackable.js\n ** module id = 18\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 19\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/css/tacit.min.css\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 22\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 23\n ** module chunks = 0\n **/","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/whatwg-fetch/fetch.js\n ** module id = 24\n ** module chunks = 0\n **/"],"sourceRoot":""}